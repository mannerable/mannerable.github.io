{"posts":[{"title":"鸿蒙面试","text":"0. 鸿蒙系统0.1 OpenHarmony0.2 HarmonyOS0.2.1 HarmonyOS 应用多模块开发怎么引入另外一个模块 0.2.1 HarmonyOS 应用与 Flutter 交互请介绍一下鸿蒙操作系统的特点和优势 分布式技术：鸿蒙操作系统采用分布式技术，能够将不同的设备连接在一起，实现设备之间的数据共享和协同工作。 微内核架构：鸿蒙操作系统采用微内核架构，具有更高的安全性和稳定性。全场景支持：鸿蒙操作系统支持多种设备，包括手机、平板、智能穿戴设备、智能家居、车载等，实现了全场景覆盖。 开放生态：鸿蒙操作系统是一个开放的生态系统，支持第三方应用开发者加入，为用户提供更多的应用和服务。 流畅体验：鸿蒙操作系统采用了先进的技术，能够提供更加流畅的用户体验，包括更快的启动速度、更低的内存占用等。 请简述华为鸿蒙操作系统的特点。鸿蒙操作系统是华为开发的全场景分布式操作系统，支持多种设备，具有低延迟、高性能、安全性强等特点。鸿蒙系统中的“一次开发，多端部署”是什么意思？ 开发者只需编写一次代码，就能在手机、平板、手表、电视、汽车等多类型设备上运行，得益于鸿蒙 OS 统一的开发环境、语言与 API，以及对设备能力的抽象封装。问题：鸿蒙操作系统支持哪些编程语言？答案：鸿蒙操作系统主要支持 Java、C/C++以及 JavaScript 等编程语言进行应用开发 1. ArkTS 语言基础JS/TS/Arkts 区别？包含，js&lt;ts&lt;arkts 但是 arkts 有些 ts js 语法是不能用的。 ArkTS 文件和 TS 文件的区别ArkTS 基于并兼容了 TS 语法，继承了 TS 的所有特性，当前，ArkTS 在 TS 的基础上主要扩展了声明式 UI 能力，让开发者能够以更简洁、更自然的方式开发高性能应用。推荐用 ArtTS 开发 UI 相关内容，TS 可以用来开发业务逻辑相关内容。 如果别人传过来的数据不知道类型能不能用 any？怎么办？ts 里包裹，log 看日志拆结构。 在 ArkTS 中如何处理异步操作？ArkTS 支持使用 async 和 await 关键字来处理异步操作。这些关键字使异步代码看起来像同步代码，并且更加易读 例如，使用任务池 API 可以创建后台任务，并将这些任务放入任务队列中等待执行。任务池会根据系统的负载情况自动调度任务到不同的工作线程上执行，从而降低整体资源的消耗并提高系统的整体性能。 请注意，由于 ArkTS 和鸿蒙系统都在不断演进和发展中，因此以上信息可能会随着版本更新而发生变化。建议在实际面试前查阅最新的官方文档和资料以获取最准确的信息。 ArkTS 中的并发和多线程处理是如何实现的？ArkTS 本身作为 UI 开发语言，主要关注于用户界面的构建和渲染，并不直接提供并发和多线程处理的 API。然而，鸿蒙系统提供了任务池（TaskPool）等并发工具，允许开发者在后台执行多线程任务。开发者可以在 ArkTS 中通过调用这些系统提供的 API 来实现并发和多线程处理。 ArkTS 的主要特点有哪些 响应式系统：支持数据驱动视图更新。 类型安全：基于 TypeScript 提供静态类型检查。 组件化开发：支持声明式的 UI 定义和复用。 跨平台：能够编译为 HarmonyOS 上运行的应用程序代码。 高性能：通过预编译和高效的运行时引擎提高应用性能。 App、HAP、HAR 的关系 App 是个上架概念，多个 HAP 打包一起上架。 HAP 是可以独立运行、分发的，HAP 不是复用的，复用的应该是 HAR。 HAR 是静态共享包，每个模块依赖的话都会打包到 HAP 里。 ####har 和 hsp 区别？只有体积大小的区别吗？ 解决体积膨胀的问题，har 是安装包直接安装在进程里 应用、元服务和卡片是什么关系 元服务也是一种应用，只不过没有图标，可以执行免安装拉起而已。 应用和元服务，不能共享包名，它们得分别打包，元服务和应用之间是分割开的，也不能共享 entry 模块 应用与元服务都可以有卡片，而不是某一方特有的。 元服务的卡片在手机上的入口，就表现为桌面卡片；在桌面长按任何一张已经添加的卡片，比如：图库和备忘录，在弹出来的菜单中选择“卡片中心”，进入卡片中心页面，可以找到卡片来添加到桌面。带下划线的桌面图标的应用表示存在服务卡片。 2. ArkUI：声明式 UI2.1 ArkUI 基础2.1.1 生命周期: 组件、页面、UIAbilitya.组件生命周期：被@Component 装饰的自定义组件的生命周期 aboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其 build()函数之前执行。通常在该生命周期发送请求获取数据。 aboutToDisappear：在自定义组件即将析构销毁时执行。 b.页面生命周期：被@Entry 装饰的组件生命周期 onPageShow：页面每次显示时触发。 onPageHide：页面每次隐藏时触发（通常是路由跳转到其他页面了）。 onBackPress：当用户点击返回按钮时时触发（是手机底部操作栏的返回按钮，不是顶部的路由返回按钮）。 c.UIAbility 生命周期：State 模型生命周期 onCreate：Create 状态为在应用加载过程中，UIAbility 实例创建完成时触发，系统会调用 onCreate()回调。可以在该回调中进行应用初始化操作，例如变量定义资源加载等，用于后续的 UI 界面展示。 onForeground：在 UIAbility 的 UI 界面可见之前，如 UIAbility 切换至前台时触发。可以在 onForeground()回调中申请系统需要的资源，或者重新申请在 onBackground()中释放的资源。 onBackground：在 UIAbility 的 UI 界面完全不可见之后，如 UIAbility 切换至后台时候触发。可以在 onBackground()回调中释放 UI 界面不可见时无用的资源，或者在此回调中执行较为耗时的操作，例如状态保存等。 onDestroy：在 UIAbility 实例销毁时触发。可以在 onDestroy()回调中进行系统资源的释放、数据的保存等操作。 UIAbility 的启动模式UIAbility 的启动模式是指在启动 UIAbility 实例时所采用的不同呈现状态和行为方式。HarmonyOS 为 UIAbility 提供了多种启动模式，以满足不同业务场景的需求。这些启动模式包括： Singleton（单实例模式） ：这是默认情况下的启动模式。当应用进程中该类型的 UIAbility 实例已经存在时，系统会复用该实例，而不是创建新的实例。这意味着每次调用 startAbility()方法时，如果相同类型的 UIAbility 实例已经存在，则不会进入 onCreate()和 onWindowStageCreate()生命周期回调，而只会进入 onNewWant()回调。这种模式下，UIAbility 在任务列表里只会有一个历史任务。 Multiton（多实例模式） ：在这种模式下，可以多次创建 UIAbility 实例。但是，每次创建新的实例之前，之前的实例都会被销毁。因此，在任务列表里也只能看到一个历史任务。每次创建新的实例时，都会重新走一遍 UIAbility 的生命周期方法。 Standard（标准实例模式） ：这也是一种多实例模式。与 Multiton 不同的是，创建新的实例时不会销毁之前的实例，所以在任务列表里可以看到多个实例。这意味着每次点击都会创建新的实例，并且每个实例都有自己的生命周期。 Specified（指定实例模式） ：这种启动模式需要指定一个 ID。在创建 UIAbility 时，系统会先判断任务列表里是否存在指定 ID 的 UIAbility 实例。如果存在，则不会创建新的实例；如果不存在，则会创建新的实例。 2.1.2 装饰器#####@builder 和@builderParam 装饰器的作用？ #####父子组件双向数据绑定: 使用 @State 和 @Link 进行数据双向绑定 说一下@state、@Link、@Builder、@Provide 和@Consume 的区别@builder 和@builderParam 装饰器样式相关装饰器@Styles 和@Extend 的使用和区别容器组件滚动可滚动组件：Scroll、List、Grid 等容器组件可以滚动。 使用过哪些原生组件，布局容器和基本控件，可以针对提一些问题。自定义组件和子组件生命周期：每个自定义组件都有自己的生命周期，但并非所有生命周期函数都对所有组件有效。自定义组件生命周期：每一个自定义组件@Component 都有自己的生命周期，但注意 Page 相关的周期只有 @Entry 的页面入口有自定义组件生命周期时机：aboutToAppear()在 build 函数之前执行。用于组件显示前的准备工作。 2.2 ArkUI 动画如何在 ArkTS 中实现动画效果？ArkTS 可以使用 Animated 组件和动画属性来实现动画效果。例如，可以使用 Animated.Value 来创建一个动画值，然后通过设置组件的属性如 width、height、opacity 等与动画值进行绑定，再使用 Animated.timing、Animated.spring 等方法来创建动画效果。 2.2 状态管理都用过哪些装饰器？@State @Watch @Link @Prop 等等，着重介绍如何使用，什么特性即可。 常用的装饰器有哪些。装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component 和@State 都是装饰器，@Component 表示自定义组件，@Entry 表示该自定义组件为入口组件，@State 表示组件中的状态变量，状态变量变化会触发 UI 刷新。 ​ 2.2.2 状态存储localStorage 和 appStorage 的区别 localStorage 和 appStorage 的区别，和对应的装饰器 localStorage 是页面级数据存储，在页面中创建实例，组件中使用@LocalStorageLink 和@LocalStorageProp 装饰器修饰对应的状态变量，绑定对应的组件使用比状态属性更灵活 appStorage 是进程级数据存储，进程启动时自动创建了唯一实例，在各个页面组件中@StorageProp 和@StorageLink 装饰器修饰对应的状态变量。 localStorage 和 appStorage 数据存取都是在主线程进行的，且 api 只提供了同步接口，存取数据时要注意数据的大小。 如何在 ArkTS 中实现数据的本地存储？ArkTS 可以使用@StorageLink 装饰器来实现数据的本地存储绑定。例如：@StorageLink(‘key’) value，其中 key 是存储的键名，value 是绑定的数据变量。通过这种方式，数据的变化会自动同步到本地存储，并且在应用启动时可以从本地存储中恢复数据。 首选项异步存储在并发场景上的注意事项首选项 preference 提供了异步存储接口，首选项的数据存储维度分为内存和沙盒，为避免内存过大导致报警，要控制首选项数据存储的数据，可以使用 await 来控制并发存储的问题 用户首选项是线程安全的吗首选项是线程安全的，所以多线程访问可以保证数据一致性，但只支持同进程，不支持多进程。 首选项底层逻辑？提供 key value 形式的 api。系统静态容器提供 pf 实例对象在内存中，对应获取沙箱中数据的文件。 注意轻量级，key 不为空且长度不超过 80 字节，value 若为 string 长度不超过 8192 字节。 2.3 UI 布局2.3.1 常见布局方式flex 导致二次布局的原因，以及调研的经历flex 中 flexgrow=1 时，子组件宽度和大于 flex 的宽度时，页面渲染后，会调整子组件宽度使之宽度和等于 flex 的宽度，造成二次布局渲染 flex 中 flexshrink=1 时，子组件宽度和小于 flex 的宽度时，页面渲染后，也会调整子组件宽度使之宽度和等于 flex 的宽度，造成二次布局渲染 页面布局上的性能和内存上的注意事项1、使用 row/column+layoutweight 代替 flex 容器使用 2、scroll 嵌套 list/grid 容器时，要设置容器的宽高，数组数据渲染尽量使用 lazyforeach 渲染 item 3、组件的显隐设置，要使用 if 语句来判断，避免使用 visibility 4、list/grid 容器要根据具体场景来使用 cachecount，避免卡顿 2.3.2 一多适配开发一套代码，UI 同时适配手机，折叠屏和平板，怎么实现媒体查询 如何在 ArkTS 中实现响应式布局？ArkTS 可以使用 Flex 布局和响应式属性来实现响应式布局。例如，可以使用 Flex 组件来创建弹性布局容器，并设置 justifyContent、alignItems 等属性来调整子元素的排列方式。同时，可以使用响应式属性如 width、height、margin 等，根据不同的设备尺寸和屏幕方向进行自适应调整。解释一下 ArkTS 中的 Stack 组件的作用。Stack 组件用于创建堆叠布局，可以将多个子组件按照指定的顺序堆叠在一起。可以设置 alignment 属性来调整子组件在堆叠方向上的对齐方式，还可以设置 clipToBounds 属性来控制子组件是否超出父容器的边界进行裁剪。 flex 为什么有性能问题？flex 为什么影响性能？flex 会二次重绘，因为 flexShrink 用过哪些组件？row column stack list swiper RelativeContainer 等等 3. 通信与调度3.1 Ability 交互三方应用调用系统应用，对于 ability 的交互和传值有什么限制？除了数据大小方面 重点介绍自己对 ability 的理解，描述显式 want 和隐式 want 的区别，带入到对应面试项目中场景来 启动应用内的 UIAbility 启动应用内的 UIAbility 并获取返回结果 启动其他应用的 UIAbility 启动其他应用的 UIAbility 并获取返回结果 启动 UIAbility 的指定页面 显式 Want 启动：在 want 参数中需要设置该应用 bundleName 和 abilityName，当需要拉起某个明确的 UIAbility 时，通常使用显式 Want 启动方式。 隐式 Want 启动：不明确指出要启动哪一个 UIAbility，在调用 startAbility()方法时，其入参 want 中指定了一系列的 entities 字段（表示目标 UIAbility 额外的类别信息，如浏览器、视频播放器）和 actions 字段（表示要执行的通用操作，如查看、分享、应用详情等）等参数信息，然后由系统去分析 want，并帮助找到合适的 UIAbility 来启动。 3.2 页面通信3.3 组件通信3.4 多线程通信3.4 路由跳转页面的跳转和数据传递组件间怎么通信，传递数据 组件通信方式有哪些？H5 页面如何与 ArkTS 交互 a ability 拉 b ability 类型会不会丢失？会丢 navigation 和 router 区别，优缺点 页面栈页面栈数量：每调用一次 router.pushUrl()方法，默认情况下，页面栈数量会增加 1。鸿蒙系统对页面栈的数量有限制，通常是 32 个。页面跳转销毁：router.replaceUrl()方法可以跳转到一个新页面，并销毁当前页面。 作者：维维喂喂微微 https://www.bilibili.com/read/cv33829990/ 出处：bilibili 4. 网络与多线程4.1 网络网络请求需要添加什么权限，在哪里添加谈谈 ArkTS 中数据请求的方法有哪些？可以使用原生的 JavaScript 中的 fetch 或 axios 等库来进行网络请求获取数据。在 ArkTS 中，可以在函数或组件的方法中调用这些库进行数据请求，并将获取的数据更新到组件的状态中，从而触发界面的更新。 网络相关的三方库有哪些网络相关的三方库有 Axios、httpclient、okdownload 等，具体分类可以参考三四方库网络分类。 如何监听网络变化在网络连接管理模块中通过 on(‘netCapabilitiesChange’)订阅网络能力变化事件，即可监听网络变化。如何获取网络类型：Wi-Fi，3G，4G，5G 等先通过 getNetCapabilities 去获取网络的类型，判断默认网络是 WIFI 还是蜂窝。 如果是 Wi-Fi，则直接确认网络类型是 Wi-Fi。如果是在蜂窝连接情况下，可以调用 radio.getSignalInformation 获取指定 SIM 卡槽对应的注册网络信号强度信息列表，返回 SignalInformation 对象的数组，其中，返回的 signalType 代表网络类型 NetworkType，signalType 的值对应网络类型如下： GSM：2GCDMA：电信 2GWCDMA：3GTDSCDMA：3GLTE：4GNR：5G 项目中接口请求的数据，需要进行缓存吗？鸿蒙化处理过程根据自己项目中的业务逻辑描述，MapKit 需要将当前屏幕中展示的 6 个瓦片数据图片缓存到沙盒中，杀掉进程后，断开网络，打开 app 会展示缓存的数据瓦片。 4.2 多线程如何判断是否为主线程有哪些创建线程的方式在 ArkTS 中使用 Worker 创建线程，Worker 线程在主线程中创建，与主线程相互独立，但不能直接操作 UI，最多可以创建 64 个 Worker 线程。在 ArkTS 中使用任务池（TaskPool）创建线程任务。通过 NAPI 机制，在 C 代码中使用标准的线程 API 创建线程。 TaskPool 和 Worker 的异同点不同点：两者是不同颗粒度的并发 API，Worker 更像 Thread 或者 Service 维度，Task 就是单一任务维度。同时 TaskPool 简化开发者开发并发程序，支持优先级和取消，并且通过统一管理节省系统资源优化调度。相同点：在 JS 相关的线程间交互上，二者本质都是内存隔离模型，参数与范围值的限制是一致的，也有开销。 Worker 和 TaskPool 的线程数量是否有限制TaskPool 内部会动态调整线程个数，不支持设置数量，只需要往线程池中抛任务，确保高优先级任务的及时执行。 Worker 的线程个数最多 64 个，如果 Worker 超过规定个数，会创建失败。 在使用时，TaskPool 与 Worker 两者独立，不相互影响，因此 Worker 在达到上限数量时，不会影响 TaskPool。Worker 是固定数量，当前是 64 个。TaskPool 线程池的数量会根据硬件条件、任务负载等情况动态调整。 在多线程并发场景中，如何实现安全访问同一块共享内存可以使用共享对象 SharedArrayBuffer 实现。SharedArrayBuffer 对象存储的数据在同时被修改时，需要通过 Atomics 原子操作保证其同步性，即下个操作开始之前务必需要等到上个操作已经结束。如何实现多线程数据共享由于 ArkTS 是单线程模型，内存隔离，因此大部分普通对象跨线程均采用序列化方式，通过 ArrayBuffer 的转移传输和 SharedArrayBuffer 进行共享。 多线程怎么保证并发一致性？队列，同步锁 多进程 sp 怎么保证一致性？分为两种情况，读，不需要处理。写，需要加锁。 主线程上的数据对象序列化后传到子线程，子线程改变了对象的属性值，主线程跟着一起改变吗不会变 子线程和主线程的消息传递目前鸿蒙线程间通信使用 emitter promise 和 callback 的区别？promise 没有解决回调的问题，因为 then 本身也是回调，但他规范一套异步的规范，符合 promise a+规范的都是 promise，这个对于写各种库的人来说规范了他们的接口格式，开发者在使用各种接口的时候不用考虑这个传啥回调那个传啥回调 promise.then 是在哪个线程里？then 里面的处理是在主线程。 .then 调用和 await 调用的区别当使用Promise进行异步操作时，可以使用.then和await两种方式来调用异步接口；.then调用不阻塞当前线程，异步回调结束后会直接走到then中，await会等待当前异步方法执行结束才会继续往下执行。 taskpool 开启子线程和 promise 的区别taskpool 开辟子线程能够充分利用现代手机设备多核配置，提高程序的并发性和运行效率；Promise 是在当前线程进行异步调用，可以避免阻塞主线程，保证程序的响应速度，提高用户体验； 具体使用场景：当需要执行I/O操作时，使用异步操作比使用线程+同步I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。当需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行时，建议使用子线程操作。 两个按钮分别调用一个异步 async 代码，里面有多个 await，他们会不会交叉进行？会交叉。async 和 await 是 promise 的语法糖，相当于将当前执行栈的任务全部包含到 then 里面 worker 和 taskpool 的区别？前者是子线程并发处理，后者是异步批量处理。worker 最多只有 8 个。taskpool 处理超过三分钟就会失效。 鸿蒙系统 http 在接口请求时，系统本身应该是开启子线程来请求，那么为什么在项目中还要使用 taskpool 开辟子线程呢鸿蒙底层的http请求实现是在子线程中进行的，但针对于请求参数的编码与返回值的解析，这部分需要花费时间来处理的业务逻辑，还是建议使用taskpool开辟子线程来处理 5.ArkWeb：与 H5 交互webview 交互，传递数据h5 跟 arkts 怎么交互？runJavaScript（） arkts-》H5 javaScriptProxy() 和 registerjavaScriptProxy() H5-》arkts 拦截 url 过滤 createWebMessagePorts postMessage onMessageEvent 数据通道 H5 页面如何与 ArkTS 交互通过对 javaScriptProxy 和 runJavaScript 封装，实现 JSBridge 通信方案。使用 Web 组件 javaScriptProxy 将原生侧接口注入到 H5 的 window 对象上，通过 runJavaScript 接口执行 JS 脚本到 H5 中，并在回调中获取脚本执行结果 7.鸿蒙 Native: NAPI####从介绍中延伸出 har 和下沉到系统的 so 的优缺点 har 分为静态分享库和动态分享库，静态分享库生成 har 包集成到应用中，应用运行时直接加载到进程中，动态分享库生成 hsp 和 har 包，har 集成到应用中，hsp 需要安装到手机设备中，应用运行时，har 直接加载到进程中，但 hsp 需要业务调用才会加载； so 是 c++和 arkts 的混编，arkts 开发完成后，编译生成对应的 js 文件，使用华为工具将 js 文件和 NAPI 混编为 so； 目前 api10 和 api11 不支持 har 包下沉到系统称为预置 SDK，仅支持 so。 8. 工具链如何使用 ohpm 引入三四方库 9.性能优化如何优化 ArkTS 组件的性能 避免不必要的重新渲染：使用@Watch 装饰器来监听数据变化，只有当相关数据发生变化时才进行组件的重新渲染。 合理使用列表渲染：对于大量数据的列表，可以使用 ForEach 组件来提高性能。 减少不必要的计算：避免在组件的 build 方法中进行复杂的计算，尽量将计算提前到数据准备阶段。 在 ArkTS 开发中，有哪些方法可以提高应用的性能？答案：可以通过优化数据结构、避免不必要的计算、合理使用缓存、减少页面的重绘和回流等方式提高应用性能。在界面开发中，尽量使用简单的布局和组件，避免过度嵌套。 解释一下 ArkTS 中的 LazyForEach 组件的作用LazyForEach 组件用于在列表渲染时实现懒加载。当列表中的项很多时，LazyForEach 可以只渲染可见区域的项，当用户滚动列表时，再逐步加载其他项，从而提高性能和减少内存占用。 list 使用有什么坑？渲染逻辑？list 默认会把 listitem 全部都渲染出来，数据量大会对内存造成压力。LazyForEach，只加载可见区域。 页面性能内存优化？性能和内存是两个指标，有时候追求性能，就需要做缓存处理，吃内存。 页面内存优化，主要在减少缓存的处理。 性能优化，主要在少嵌套，减少动态渲染的频率。 装饰器,组件间通信,性能优化,数据持久化存取lazyforeach 使用相关的10. 实际项目中遇到的疑难问题与解决方法遇到过什么问题 分享一个你在使用 ArkTS 开发过程中遇到并解决的实际问题","link":"/2025/05/12/%E9%B8%BF%E8%92%99%E9%9D%A2%E8%AF%95/"}],"tags":[],"categories":[],"pages":[]}