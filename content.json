{"posts":[{"title":"鸿蒙面试笔记","text":"0. 鸿蒙系统请介绍一下鸿蒙操作系统的特点和优势 分布式技术：鸿蒙操作系统采用分布式技术，能够将不同的设备连接在一起，实现设备之间的数据共享和协同工作。 微内核架构：鸿蒙操作系统采用微内核架构，具有更高的安全性和稳定性。全场景支持：鸿蒙操作系统支持多种设备，包括手机、平板、智能穿戴设备、智能家居、车载等，实现了全场景覆盖。 开放生态：鸿蒙操作系统是一个开放的生态系统，支持第三方应用开发者加入，为用户提供更多的应用和服务。 流畅体验：鸿蒙操作系统采用了先进的技术，能够提供更加流畅的用户体验，包括更快的启动速度、更低的内存占用等。 0.1 OpenHarmony一、核心定位与性质 ‌维度‌ ‌OpenHarmony‌ ‌HarmonyOS‌ ‌性质‌ 开源操作系统（开放原子开源基金会运营） 华为基于 OpenHarmony 开发的闭源商用系统 ‌目标‌ 构建全场景分布式操作系统底座，全行业可用 为华为设备提供专属优化，构建商业生态 ‌开源协议‌ Apache 2.0（允许二次开发与商用） 闭源，仅华为设备使用 二、技术架构差异 能力‌ ‌OpenHarmony‌ ‌HarmonyOS‌ ‌内核支持‌ 多内核设计（Linux/LiteOS），支持轻量至标准系统 913 继承 OpenHarmony 内核，深度优化华为硬件 56 ‌分布式能力‌ 提供基础分布式框架（软总线/数据管理）913 增强分布式协同（如超级终端一拉即连）612 ‌安卓兼容性‌ ‌不兼容‌安卓 APK 26 HarmonyOS NEXT（5.0+）‌移除安卓兼容层‌，仅支持原生鸿蒙应用 613 ‌闭源组件‌ 无 集成 HMS Core、方舟编译器等专有技术 0.2 HarmonyOS请简述华为鸿蒙操作系统的特点。鸿蒙操作系统是华为开发的全场景分布式操作系统，支持多种设备，具有低延迟、高性能、安全性强等特点。 鸿蒙系统中的“一次开发，多端部署”是什么意思？开发者只需编写一次代码，就能在手机、平板、手表、电视、汽车等多类型设备上运行，得益于鸿蒙 OS 统一的开发环境、语言与 API，以及对设备能力的抽象封装。 鸿蒙操作系统支持哪些编程语言？鸿蒙操作系统主要支持 Java、C/C++以及 JavaScript 等编程语言进行应用开发 0.2.1 HarmonyOS 应用多模块开发App、HAP、HAR 的关系 App 是个上架概念，多个 HAP 打包一起上架。 HAP 是可以独立运行、分发的，HAP 不是复用的，复用的应该是 HAR。 HAR 是静态共享包，每个模块依赖的话都会打包到 HAP 里。 har 和 hsp 区别？只有体积大小的区别吗？解决体积膨胀的问题，har 是安装包直接安装在进程里 0.2.2 HarmonyOS 应用与 Flutter 交互要想鸿蒙支持flutter需要flutter sdk对应鸿蒙版本兼容，Gitcode中有维护flutter_flutter，具体配置可以参考readme。另外，flutter只是一个UI框架，但凡涉及到与硬件或者操作系统相关的操作，例如：获取相册图片、获取文件、连接蓝牙等，都需要利用三方库或自己实现flutter与原生的交互。一般三方库如果有对应Android和iOS的实现，没有鸿蒙的实现那么就需要自己通过methodChanel实现对应的鸿蒙平台实现三方库进行鸿蒙化。 1. ArkTS 语言基础JS/TS/Arkts 区别？包含，js&lt;ts&lt;arkts 但是 arkts 有些 ts js 语法是不能用的。 ArkTS 文件和 TS 文件的区别ArkTS 基于并兼容了 TS 语法，继承了 TS 的所有特性，当前，ArkTS 在 TS 的基础上主要扩展了声明式 UI 能力，让开发者能够以更简洁、更自然的方式开发高性能应用。推荐用 ArtTS 开发 UI 相关内容，TS 可以用来开发业务逻辑相关内容。 如果别人传过来的数据不知道类型能不能用 any？怎么办？ts 里包裹，log 看日志拆结构。 在 ArkTS 中如何处理异步操作？ArkTS 支持使用 async 和 await 关键字来处理异步操作。这些关键字使异步代码看起来像同步代码，并且更加易读 例如，使用任务池 API 可以创建后台任务，并将这些任务放入任务队列中等待执行。任务池会根据系统的负载情况自动调度任务到不同的工作线程上执行，从而降低整体资源的消耗并提高系统的整体性能。 请注意，由于 ArkTS 和鸿蒙系统都在不断演进和发展中，因此以上信息可能会随着版本更新而发生变化。建议在实际面试前查阅最新的官方文档和资料以获取最准确的信息。 ArkTS 中的并发和多线程处理是如何实现的？ArkTS 本身作为 UI 开发语言，主要关注于用户界面的构建和渲染，并不直接提供并发和多线程处理的 API。然而，鸿蒙系统提供了任务池（TaskPool）等并发工具，允许开发者在后台执行多线程任务。开发者可以在 ArkTS 中通过调用这些系统提供的 API 来实现并发和多线程处理。 ArkTS 的主要特点有哪些 响应式系统：支持数据驱动视图更新。 类型安全：基于 TypeScript 提供静态类型检查。 组件化开发：支持声明式的 UI 定义和复用。 跨平台：能够编译为 HarmonyOS 上运行的应用程序代码。 高性能：通过预编译和高效的运行时引擎提高应用性能。 应用、元服务和卡片是什么关系 元服务也是一种应用，只不过没有图标，可以执行免安装拉起而已。 应用和元服务，不能共享包名，它们得分别打包，元服务和应用之间是分割开的，也不能共享 entry 模块 应用与元服务都可以有卡片，而不是某一方特有的。 元服务的卡片在手机上的入口，就表现为桌面卡片；在桌面长按任何一张已经添加的卡片，比如：图库和备忘录，在弹出来的菜单中选择“卡片中心”，进入卡片中心页面，可以找到卡片来添加到桌面。带下划线的桌面图标的应用表示存在服务卡片。 2. ArkUI：声明式 UI大前端包括Android、iOS、鸿蒙、flutter等在内，在大的趋势上都逐步往声明式UI的方向发展，目前已有的声明式UI开发框架有； H5：React、Vue Android：Jetpack Compose iOS：SwiftUI HarmonyOS：ArkUI 跨平台：Flutter、React Native 2.1 ArkUI 基础2.1.1 生命周期: 组件、页面、UIAbilitya.组件生命周期：被@Component 装饰的自定义组件的生命周期 aboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其 build()函数之前执行。通常在该生命周期发送请求获取数据。 aboutToDisappear：在自定义组件即将析构销毁时执行。 b.页面生命周期：被@Entry 装饰的组件生命周期 onPageShow：页面每次显示时触发。 onPageHide：页面每次隐藏时触发（通常是路由跳转到其他页面了）。 onBackPress：当用户点击返回按钮时时触发（是手机底部操作栏的返回按钮，不是顶部的路由返回按钮）。 c.UIAbility 生命周期：State 模型生命周期 onCreate：Create 状态为在应用加载过程中，UIAbility 实例创建完成时触发，系统会调用 onCreate()回调。可以在该回调中进行应用初始化操作，例如变量定义资源加载等，用于后续的 UI 界面展示。 onForeground：在 UIAbility 的 UI 界面可见之前，如 UIAbility 切换至前台时触发。可以在 onForeground()回调中申请系统需要的资源，或者重新申请在 onBackground()中释放的资源。 onBackground：在 UIAbility 的 UI 界面完全不可见之后，如 UIAbility 切换至后台时候触发。可以在 onBackground()回调中释放 UI 界面不可见时无用的资源，或者在此回调中执行较为耗时的操作，例如状态保存等。 onDestroy：在 UIAbility 实例销毁时触发。可以在 onDestroy()回调中进行系统资源的释放、数据的保存等操作。 UIAbility 的启动模式UIAbility 的启动模式是指在启动UIAbility 实例时所采用的不同呈现状态和行为方式。HarmonyOS 为 UIAbility 提供了多种启动模式，以满足不同业务场景的需求。这些启动模式包括： Singleton（单实例模式） ：这是默认情况下的启动模式。当应用进程中该类型的 UIAbility 实例已经存在时，系统会复用该实例，而不是创建新的实例。这意味着每次调用 startAbility()方法时，如果相同类型的 UIAbility 实例已经存在，则不会进入 onCreate()和 onWindowStageCreate()生命周期回调，而只会进入 onNewWant()回调。这种模式下，UIAbility 在任务列表里只会有一个历史任务。 Multiton（多实例模式） ：在这种模式下，可以多次创建 UIAbility 实例。但是，每次创建新的实例之前，之前的实例都会被销毁。因此，在任务列表里也只能看到一个历史任务。每次创建新的实例时，都会重新走一遍 UIAbility 的生命周期方法。 Standard（标准实例模式） ：这也是一种多实例模式。与 Multiton 不同的是，创建新的实例时不会销毁之前的实例，所以在任务列表里可以看到多个实例。这意味着每次点击都会创建新的实例，并且每个实例都有自己的生命周期。 Specified（指定实例模式） ：这种启动模式需要指定一个 ID。在创建 UIAbility 时，系统会先判断任务列表里是否存在指定 ID 的 UIAbility 实例。如果存在，则不会创建新的实例；如果不存在，则会创建新的实例。 2.1.2 装饰器@builder 和@builderParam 装饰器的作用？ @Builder装饰器 ‌作用‌：用于将重复的UI结构抽象为可复用的函数，支持组件内或全局范围的UI复用 特性‌： 作用域控制‌：可以在组件内定义（私有）或全局定义（共享） 状态访问‌：组件内通过this直接访问状态变量，实现动态更新 ‌参数传递‌：支持按值传递（默认）或按引用传递（使用$$范式） 使用场景‌：减少冗余代码，例如将多个Text组件抽取为统一的构建函数 @BuilderParam装饰器 作用‌：用于装饰指向@Builder函数的变量，实现UI逻辑的动态注入，类似于“插槽”机制 ‌特性‌： ‌动态定制‌：允许父组件向子组件传递UI模板，实现功能解耦 兼容性‌：支持ArkTS卡片（API 9+）和元服务（API 11+） ‌使用场景‌：通用组件开发（如列表、选项卡），子组件的UI由使用方动态传入 对比与关联 关系‌：@BuilderParam是@Builder的扩展，用于接收外部传入的UI模板 差异‌：@Builder侧重复用，@BuilderParam侧重动态插槽功能 // @Builder示例（组件内复用） @Component struct MyComponent { @State count: number = 0; @Builder CounterUI() { Row() { Button('+').onClick(() =&gt; this.count++); Text(`Count: ${this.count}`); } } build() { Column() { this.CounterUI(); // 调用构建函数 } } } // @BuilderParam示例（动态插槽） @Component struct ChildComponent { @BuilderParam customUI: () =&gt; void; build() { Column() { this.customUI(); // 渲染父组件传入的UI } } } 12345678910111213141516171819202122232425262728293031##### 说一下@state、@Link、@Builder、@Provide 和@Consume 的区别- @State：组件内部状态管理 - **作用**‌：声明组件私有状态变量，变更时自动触发‌**当前组件**‌的 UI 刷新 - **数据流向**‌：单向（内部驱动） - ‌**典型场景**‌：管理组件自身状态（如按钮点击计数）- @Link：父子组件双向绑定 - ‌**作用**‌：建立父子组件间的‌**双向数据同步**‌。子组件修改数据会同步更新父组件状态 - ‌**数据流向**‌：双向（父子互斥） - **典型场景**‌：表单控件（如子组件输入框实时修改父组件数据）- @Builder：UI 模板复用 - **作用**‌：封装可复用的 UI 片段，‌**非状态管理装饰器**‌ - **特性**‌： - 支持作用域（组件内/全局）和参数传递 - 与状态变量解耦，需手动注入状态（如 `this.xxx`） - **典型场景**‌：抽离重复布局（如统一按钮样式） ```typescript @Builder ButtonTemplate(text: string) { Button(text).backgroundColor(Color.Blue); } @Provide / @Consume：跨组件层级共享 ‌作用‌：实现‌祖先组件向后代组件‌的数据穿透，支持双向同步 数据流向‌：双向（跨层级传递） 对比 @Link‌： | 特性 | @Provide / @Consume | @Link | | ---------- | ------------------- | ------- | | ‌**通信层级**‌ | 任意跨层级 | 仅父子组件 | | ‌**代码量**‌ | 更简洁（无需逐层传递） | 需显式传递变量 | 对比小结： 装饰器 作用范围 数据流向 典型场景 @State ‌组件内部‌ 单向 自身状态管理（如计数器） @Link ‌父子组件‌ 双向 表单控件双向同步 @Builder UI 模板复用 - 封装通用 UI 结构 @Provide/@Consume ‌跨任意层级‌ 双向 全局配置（主题、语言） 样式相关装饰器@Styles 和@Extend 的使用和区别容器组件滚动可滚动组件：Scroll、List、Grid 等容器组件可以滚动。 使用过哪些原生组件，布局容器和基本控件，可以针对提一些问题。自定义组件和子组件生命周期：每个自定义组件都有自己的生命周期，但并非所有生命周期函数都对所有组件有效。自定义组件生命周期：每一个自定义组件@Component 都有自己的生命周期，但注意 Page 相关的周期只有 @Entry 的页面入口有自定义组件生命周期时机：aboutToAppear()在 build 函数之前执行。用于组件显示前的准备工作。 2.2 ArkUI 动画如何在 ArkTS 中实现动画效果？ArkTS 可以使用 Animated 组件和动画属性来实现动画效果。例如，可以使用 Animated.Value 来创建一个动画值，然后通过设置组件的属性如 width、height、opacity 等与动画值进行绑定，再使用 Animated.timing、Animated.spring 等方法来创建动画效果。 2.2 状态管理都用过哪些装饰器？@State @Watch @Link @Prop 等等，着重介绍如何使用，什么特性即可。 常用的装饰器有哪些。装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component 和@State 都是装饰器，@Component 表示自定义组件，@Entry 表示该自定义组件为入口组件，@State 表示组件中的状态变量，状态变量变化会触发 UI 刷新。 ​ 2.2.2 状态存储localStorage 和 appStorage 的区别 localStorage 和 appStorage 的区别，和对应的装饰器 localStorage 是页面级数据存储，在页面中创建实例，组件中使用@LocalStorageLink 和@LocalStorageProp 装饰器修饰对应的状态变量，绑定对应的组件使用比状态属性更灵活 appStorage 是进程级数据存储，进程启动时自动创建了唯一实例，在各个页面组件中@StorageProp 和@StorageLink 装饰器修饰对应的状态变量。 localStorage 和 appStorage 数据存取都是在主线程进行的，且 api 只提供了同步接口，存取数据时要注意数据的大小。 如何在 ArkTS 中实现数据的本地存储？ArkTS 可以使用@StorageLink 装饰器来实现数据的本地存储绑定。例如：@StorageLink(‘key’) value，其中 key 是存储的键名，value 是绑定的数据变量。通过这种方式，数据的变化会自动同步到本地存储，并且在应用启动时可以从本地存储中恢复数据。 首选项异步存储在并发场景上的注意事项首选项 preference 提供了异步存储接口，首选项的数据存储维度分为内存和沙盒，为避免内存过大导致报警，要控制首选项数据存储的数据，可以使用 await 来控制并发存储的问题 用户首选项是线程安全的吗首选项是线程安全的，所以多线程访问可以保证数据一致性，但只支持同进程，不支持多进程。 首选项底层逻辑？提供 key value 形式的 api。系统静态容器提供 pf 实例对象在内存中，对应获取沙箱中数据的文件。 注意轻量级，key 不为空且长度不超过 80 字节，value 若为 string 长度不超过 8192 字节。 2.3 UI 布局2.3.1 常见布局方式flex 导致二次布局的原因，以及调研的经历flex 中 flexgrow=1 时，子组件宽度和大于 flex 的宽度时，页面渲染后，会调整子组件宽度使之宽度和等于 flex 的宽度，造成二次布局渲染 flex 中 flexshrink=1 时，子组件宽度和小于 flex 的宽度时，页面渲染后，也会调整子组件宽度使之宽度和等于 flex 的宽度，造成二次布局渲染 页面布局上的性能和内存上的注意事项1、使用 row/column+layoutweight 代替 flex 容器使用 2、scroll 嵌套 list/grid 容器时，要设置容器的宽高，数组数据渲染尽量使用 lazyforeach 渲染 item 3、组件的显隐设置，要使用 if 语句来判断，避免使用 visibility 4、list/grid 容器要根据具体场景来使用 cachecount，避免卡顿 2.3.2 一多适配开发一套代码，UI 同时适配手机，折叠屏和平板，怎么实现媒体查询 如何在 ArkTS 中实现响应式布局？ArkTS 可以使用 Flex 布局和响应式属性来实现响应式布局。例如，可以使用 Flex 组件来创建弹性布局容器，并设置 justifyContent、alignItems 等属性来调整子元素的排列方式。同时，可以使用响应式属性如 width、height、margin 等，根据不同的设备尺寸和屏幕方向进行自适应调整。解释一下 ArkTS 中的 Stack 组件的作用。Stack 组件用于创建堆叠布局，可以将多个子组件按照指定的顺序堆叠在一起。可以设置 alignment 属性来调整子组件在堆叠方向上的对齐方式，还可以设置 clipToBounds 属性来控制子组件是否超出父容器的边界进行裁剪。 flex 为什么有性能问题？flex 为什么影响性能？flex 会二次重绘，因为 flexShrink 用过哪些组件？row column stack list swiper RelativeContainer 等等 3. 通信与调度3.1 Ability 交互三方应用调用系统应用，对于 ability 的交互和传值有什么限制？除了数据大小方面 重点介绍自己对 ability 的理解，描述显式 want 和隐式 want 的区别，带入到对应面试项目中场景来 启动应用内的 UIAbility 启动应用内的 UIAbility 并获取返回结果 启动其他应用的 UIAbility 启动其他应用的 UIAbility 并获取返回结果 启动 UIAbility 的指定页面 显式 Want 启动：在 want 参数中需要设置该应用 bundleName 和 abilityName，当需要拉起某个明确的 UIAbility 时，通常使用显式 Want 启动方式。 隐式 Want 启动：不明确指出要启动哪一个 UIAbility，在调用 startAbility()方法时，其入参 want 中指定了一系列的 entities 字段（表示目标 UIAbility 额外的类别信息，如浏览器、视频播放器）和 actions 字段（表示要执行的通用操作，如查看、分享、应用详情等）等参数信息，然后由系统去分析 want，并帮助找到合适的 UIAbility 来启动。 3.2 页面通信3.3 组件通信3.4 多线程通信3.4 路由跳转页面的跳转和数据传递组件间怎么通信，传递数据 组件通信方式有哪些？H5 页面如何与 ArkTS 交互 a ability 拉 b ability 类型会不会丢失？会丢 navigation 和 router 区别，优缺点 页面栈页面栈数量：每调用一次 router.pushUrl()方法，默认情况下，页面栈数量会增加 1。鸿蒙系统对页面栈的数量有限制，通常是 32 个。页面跳转销毁：router.replaceUrl()方法可以跳转到一个新页面，并销毁当前页面。 作者：维维喂喂微微 https://www.bilibili.com/read/cv33829990/ 出处：bilibili 4. 网络与多线程4.1 网络网络请求需要添加什么权限，在哪里添加谈谈 ArkTS 中数据请求的方法有哪些？可以使用原生的 JavaScript 中的 fetch 或 axios 等库来进行网络请求获取数据。在 ArkTS 中，可以在函数或组件的方法中调用这些库进行数据请求，并将获取的数据更新到组件的状态中，从而触发界面的更新。 网络相关的三方库有哪些网络相关的三方库有 Axios、httpclient、okdownload 等，具体分类可以参考三四方库网络分类。 如何监听网络变化在网络连接管理模块中通过 on(‘netCapabilitiesChange’)订阅网络能力变化事件，即可监听网络变化。如何获取网络类型：Wi-Fi，3G，4G，5G 等先通过 getNetCapabilities 去获取网络的类型，判断默认网络是 WIFI 还是蜂窝。 如果是 Wi-Fi，则直接确认网络类型是 Wi-Fi。如果是在蜂窝连接情况下，可以调用 radio.getSignalInformation 获取指定 SIM 卡槽对应的注册网络信号强度信息列表，返回 SignalInformation 对象的数组，其中，返回的 signalType 代表网络类型 NetworkType，signalType 的值对应网络类型如下： GSM：2GCDMA：电信 2GWCDMA：3GTDSCDMA：3GLTE：4GNR：5G 项目中接口请求的数据，需要进行缓存吗？鸿蒙化处理过程根据自己项目中的业务逻辑描述，MapKit 需要将当前屏幕中展示的 6 个瓦片数据图片缓存到沙盒中，杀掉进程后，断开网络，打开 app 会展示缓存的数据瓦片。 4.2 多线程如何判断是否为主线程有哪些创建线程的方式在 ArkTS 中使用 Worker 创建线程，Worker 线程在主线程中创建，与主线程相互独立，但不能直接操作 UI，最多可以创建 64 个 Worker 线程。在 ArkTS 中使用任务池（TaskPool）创建线程任务。通过 NAPI 机制，在 C 代码中使用标准的线程 API 创建线程。 TaskPool 和 Worker 的异同点不同点：两者是不同颗粒度的并发 API，Worker 更像 Thread 或者 Service 维度，Task 就是单一任务维度。同时 TaskPool 简化开发者开发并发程序，支持优先级和取消，并且通过统一管理节省系统资源优化调度。相同点：在 JS 相关的线程间交互上，二者本质都是内存隔离模型，参数与范围值的限制是一致的，也有开销。 Worker 和 TaskPool 的线程数量是否有限制TaskPool 内部会动态调整线程个数，不支持设置数量，只需要往线程池中抛任务，确保高优先级任务的及时执行。 Worker 的线程个数最多 64 个，如果 Worker 超过规定个数，会创建失败。 在使用时，TaskPool 与 Worker 两者独立，不相互影响，因此 Worker 在达到上限数量时，不会影响 TaskPool。Worker 是固定数量，当前是 64 个。TaskPool 线程池的数量会根据硬件条件、任务负载等情况动态调整。 在多线程并发场景中，如何实现安全访问同一块共享内存可以使用共享对象 SharedArrayBuffer 实现。SharedArrayBuffer 对象存储的数据在同时被修改时，需要通过 Atomics 原子操作保证其同步性，即下个操作开始之前务必需要等到上个操作已经结束。如何实现多线程数据共享由于 ArkTS 是单线程模型，内存隔离，因此大部分普通对象跨线程均采用序列化方式，通过 ArrayBuffer 的转移传输和 SharedArrayBuffer 进行共享。 多线程怎么保证并发一致性？队列，同步锁 多进程 sp 怎么保证一致性？分为两种情况，读，不需要处理。写，需要加锁。 主线程上的数据对象序列化后传到子线程，子线程改变了对象的属性值，主线程跟着一起改变吗不会变 子线程和主线程的消息传递目前鸿蒙线程间通信使用 emitter promise 和 callback 的区别？promise 没有解决回调的问题，因为 then 本身也是回调，但他规范一套异步的规范，符合 promise a+规范的都是 promise，这个对于写各种库的人来说规范了他们的接口格式，开发者在使用各种接口的时候不用考虑这个传啥回调那个传啥回调 promise.then 是在哪个线程里？then 里面的处理是在主线程。 .then 调用和 await 调用的区别当使用Promise进行异步操作时，可以使用.then和await两种方式来调用异步接口；.then调用不阻塞当前线程，异步回调结束后会直接走到then中，await会等待当前异步方法执行结束才会继续往下执行。 taskpool 开启子线程和 promise 的区别taskpool 开辟子线程能够充分利用现代手机设备多核配置，提高程序的并发性和运行效率；Promise 是在当前线程进行异步调用，可以避免阻塞主线程，保证程序的响应速度，提高用户体验； 具体使用场景：当需要执行I/O操作时，使用异步操作比使用线程+同步I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。当需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行时，建议使用子线程操作。 两个按钮分别调用一个异步 async 代码，里面有多个 await，他们会不会交叉进行？会交叉。async 和 await 是 promise 的语法糖，相当于将当前执行栈的任务全部包含到 then 里面 worker 和 taskpool 的区别？前者是子线程并发处理，后者是异步批量处理。worker 最多只有 8 个。taskpool 处理超过三分钟就会失效。 鸿蒙系统 http 在接口请求时，系统本身应该是开启子线程来请求，那么为什么在项目中还要使用 taskpool 开辟子线程呢鸿蒙底层的http请求实现是在子线程中进行的，但针对于请求参数的编码与返回值的解析，这部分需要花费时间来处理的业务逻辑，还是建议使用taskpool开辟子线程来处理 5.ArkWeb：与 H5 交互webview 交互，传递数据h5 跟 arkts 怎么交互？runJavaScript（） arkts-》H5 javaScriptProxy() 和 registerjavaScriptProxy() H5-》arkts 拦截 url 过滤 createWebMessagePorts postMessage onMessageEvent 数据通道 H5 页面如何与 ArkTS 交互通过对 javaScriptProxy 和 runJavaScript 封装，实现 JSBridge 通信方案。使用 Web 组件 javaScriptProxy 将原生侧接口注入到 H5 的 window 对象上，通过 runJavaScript 接口执行 JS 脚本到 H5 中，并在回调中获取脚本执行结果 7.鸿蒙 Native: NAPI从介绍中延伸出 har 和下沉到系统的 so 的优缺点har 分为静态分享库和动态分享库，静态分享库生成 har 包集成到应用中，应用运行时直接加载到进程中，动态分享库生成 hsp 和 har 包，har 集成到应用中，hsp 需要安装到手机设备中，应用运行时，har 直接加载到进程中，但 hsp 需要业务调用才会加载； so 是 c++和 arkts 的混编，arkts 开发完成后，编译生成对应的 js 文件，使用华为工具将 js 文件和 NAPI 混编为 so； 目前 api10 和 api11 不支持 har 包下沉到系统称为预置 SDK，仅支持 so。 8. 工具链如何使用 ohpm 引入三四方库 9.性能优化如何优化 ArkTS 组件的性能 避免不必要的重新渲染：使用@Watch 装饰器来监听数据变化，只有当相关数据发生变化时才进行组件的重新渲染。 合理使用列表渲染：对于大量数据的列表，可以使用 ForEach 组件来提高性能。 减少不必要的计算：避免在组件的 build 方法中进行复杂的计算，尽量将计算提前到数据准备阶段。 在 ArkTS 开发中，有哪些方法可以提高应用的性能？答案：可以通过优化数据结构、避免不必要的计算、合理使用缓存、减少页面的重绘和回流等方式提高应用性能。在界面开发中，尽量使用简单的布局和组件，避免过度嵌套。 解释一下 ArkTS 中的 LazyForEach 组件的作用LazyForEach 组件用于在列表渲染时实现懒加载。当列表中的项很多时，LazyForEach 可以只渲染可见区域的项，当用户滚动列表时，再逐步加载其他项，从而提高性能和减少内存占用。 list 使用有什么坑？渲染逻辑？list 默认会把 listitem 全部都渲染出来，数据量大会对内存造成压力。LazyForEach，只加载可见区域。 页面性能内存优化？性能和内存是两个指标，有时候追求性能，就需要做缓存处理，吃内存。 页面内存优化，主要在减少缓存的处理。 性能优化，主要在少嵌套，减少动态渲染的频率。 装饰器,组件间通信,性能优化,数据持久化存取lazyforeach 使用相关的10. 实际项目中遇到的疑难问题与解决方法遇到过什么问题 分享一个你在使用 ArkTS 开发过程中遇到并解决的实际问题","link":"/2025/05/12/%E9%B8%BF%E8%92%99%E9%9D%A2%E8%AF%95/"},{"title":"实用小软件","text":"软件： Snipate：截图 f1截图，f1+fn f3定在屏幕上，f3+fn 取色：shift切换 ZoomIt：画笔 ctrl+1放大 Ctrl+2画图 画图时按住Ctrl是矩形 画图时按住tab是椭圆 画图时按字母切换画笔颜色。r红色、b蓝色、g绿色、p粉色、o橙色 XMind：思维导图 enter同级 tab下级 Typora：Markdown 主题可下载","link":"/2022/12/04/%E5%AE%9E%E7%94%A8%E5%B0%8F%E8%BD%AF%E4%BB%B6/"},{"title":"vscode实用小记","text":"VSCode插件： Error Lens：报错 One Dark Pro：颜色主题 Live Server ：实时预览，左右分屏 Auto Rename Tag：修改名字 Open In Browser：浏览器中打开 VSCode Icons：设置文件图标 Easy Less：less编译 CSSREM vscode快捷键： shift+alt+下箭头(上箭头)：复制一行 ctrl+d：选中多个相同的单词 ctrl+alt+下箭头(上箭头)：添加多个光标 ctrl+h：全局替换某个单词 ctrl+g：跳转到指定的某一行 shift+alt+鼠标选中：选中某一区块","link":"/2021/03/10/vscode%E5%AE%9E%E7%94%A8%E5%B0%8F%E8%AE%B0/"},{"title":"设计模式","text":"设计模式1. 设计模式概述23种设计模式可以分为三大类： 创建型模式5种 结构型模式7种 行为型模式11种 软件设计原则 开闭原则：对扩展开放，对修改关系。接口和抽象类，增加派生类即可。 里氏代换原则：子类继承父类的方法，尽量不要改变父类方法的功能。 依赖倒转原则：高层模块不依赖于低层模块，两者应该依赖其抽象，抽象不应该依赖细节，细节应该依抽象。具体实现可以参考泛型的思想。 接口隔离原则：最小化依赖。一个类对另一个类的依赖应该建立在最小的接口上。 迪米特法则：最小知识原则，不跟”陌生人”说话，降低耦合度。与当前对象存在关联、聚合、组合关系，可直接访问的。 合成复用原则：尽量先试用组合或者聚合等关联关系实现，其次才考虑继承关系来实现。继承为白盒复用，合成复用为黑盒复用。 UML图-统一建模语言 定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等9种图 类图：field/method +：表示public -：表示private #：表示protected 属性完整表示方式：可见性 名称 ： 类型 [ = 缺省值] 方法完整表示方式：可见性 名称：（参数列表）[：返回类型] 备注：中括号里面的内容为可选 类与类之间的关系： 关联关系一般分为：一般关联关系、聚合关系、组合关系 一般关联关系又可以分为：单向关联、双向关联、自关联 关联关系 单向关联：带箭头的实线 双向关联：不带箭头的实线 自关联：带有箭头且指向自身的实线 聚合关联关系：是强关联关系，是整体和部分之间的关系。聚合关系也是通过成员对象来实现的，成员对象是整体对象的一部分，成员对象可以脱离整体对象而独立存在。空心菱形的实线表示，菱形指向整体。例如：学校和老师的关系。 组合关系：也是整体和部分的关系，但它是一种更强烈的聚合关系。整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也不存在，部分对象不能脱离整体而存在。实心菱形的实线表示，菱形指向整体。例如：头和嘴的关系。 依赖关系：它是耦合度最弱的关联关系，是临时性的关系。带箭头的虚线表示，箭头从使用类指向被依赖的类。例如：人开车，其中人和汽车的关系。 继承关系：继承关系(泛化关系)是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类的关系，是一种继承关系。空心三角箭头的实线表示，箭头从子类指向父类。例如：父亲和儿子。 实现关系：实现类实现了接口中所声明的所有抽象方法。带空心三角箭头的虚线表示，箭头从实现类指向接口。例如：交通工具与汽车的关系。 2. 创建型模式（5种）实现创建和使用分离。 2.1 单例模式singleton pattern 分为两种： 饿汉式：类加载就会导致该单例对象被创建 懒汉式：类加载不会导致该单例对象被创建，而是首次使用该对象时会被创建 //饿汉式-静态变量创建的对象-方式1 123456789101112131415public class Singleton { //私有构造方法 private Singleton(){ //在成员位置创建该类的对象 private static Singleton instance = new Singleton(); //对外提供静态方法获取该对象 public static Singleton getInstance(){ return instance; } }} 饿汉式-在静态代码块中创建该类对象-方式2 12345678910111213141516public class Singleton { //私有构造方法 private Singleton(){} private static Singleton instance; static { instance = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance(){ return instance; }} 饿汉式-枚举方式-方式3 枚举类实现单例模式是极力推荐的单例实现方式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。 123public enum Singleton{ INSTANCE;} 懒汉式-线程不安全-方式1 1234567891011121314151617public class Singleton { //私有构造方法 private Singleton(){} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; }} 懒汉式-线程安全-方式2 1234567891011121314151617public class Singleton { //私有构造方法 private Singleton(){} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static synchronized Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; }} 懒汉式-双重检查锁-方式3 方式2中加锁操作虽然线程安全，但是也有性能问题，因为绝大多数的操作是读操作，而读操作本身就是线程安全的，没必要去加锁。所以，没有必要让每个线程必须持有锁才能调用getInstance。需要调整加锁的时机，由此产生下面双重检查锁的方式。 123456789101112131415161718192021222324public class Singleton { //私有构造方法 private Singleton(){} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 //volatile解决多线程中空指针问题(JVM在实例化对象的时候会进行优化和指令重排序操作，使用volatile保证可见性和有序性) public static volatile Singleton getInstance(){ //第一次判断，如果instance的值不为null，不需要抢占锁，直接返回对象 if(instance == null){ synchronized (Singleton.class){ //第二次判断 if(instance == null){ instance = new Singleton(); } } } return instance; }} 懒汉式-静态内部类-方式4 静态内部类单例模式中实例由内部类创建，由于JVM中加载外部类的过程中，是不会有加载静态内部类的，只有内部类的属性/方法被调用才会被加载，并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且能严格保证实例化顺序。 静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式，在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。 1234567891011121314public class Singleton { //私有构造方法 private Singleton(){} //在成员位置创建该类的对象 private static class SingletonHolder{ private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance(){ return SingletonHolder.INSTANCE;} 存在的问题 破坏单例模式：使用上面的单例类可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。 通过readResolve()可以解决序列化破坏单例模式的问题。 通过在私有构造方法中添加代码可以解决破坏单例模式的问题。 123456789101112131415161718192021222324252627282930public class Singleton { //私有构造方法 private Singleton(){ //反射破坏单例模式需要添加的代码 if(instance !=null){ throw new RuntimeException(); } } //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 //volatile解决多线程中空指针问题(JVM在实例化对象的时候会进行优化和指令重排序操作，使用volatile保证可见性和有序性) public static volatile Singleton getInstance(){ //第一次判断，如果instance的值不为null，不需要抢占锁，直接返回对象 if(instance == null){ synchronized (Singleton.class){ //第二次判断 if(instance == null){ instance = new Singleton(); } } } return instance; }} JDK的源码解析-Runtime类 Runtime类使用的就是单例设计模式。 2.2 工厂方法模式实际应用场景： 证券分类：股票（沪市（主板、科创板）、深市（主板、创业板）、京市（新三板、创新层））、债券（国债、公司债）、基金（公募基金、ETF基金）等都是证券，这里的证券就是抽象产品，而股票等就是具体产品。证券代码、证券价格等就是抽象工厂中应该定义的，具体工厂就是 Coffee类 addSugar addMilk 抽象类 美式咖啡、拿铁咖啡 实现类 工厂模式最大的优点就是解耦。 简单工厂模式，不是一种设计模式，反而像是一种编程习惯。 静态工厂模式，不是一种设计模式，也只是一种编程习惯。 针对上面的问题，我们可以使用工厂方法模式，完全遵循开闭原则。 定义一个用于创建对象的接口，让子类决定石化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类中。 工厂方法模式： 抽象工厂(Abstract Factory)：提供了创建产品的接口，调用者通过它访问具体的工厂方法来创建产品。-接口 具体工厂(Concrete Factory)：主要是实现抽象工厂中的抽象方法，完成具体产品创建。 抽象产品(Product)：定义了产品规范 ，描述了产品的主要特征和功能。 具体产品(Concrete Product)：实现了抽象产品角色定义的接口，由具体工厂来创建，同具体工厂一一对应。 优缺点： 优点： 用户只需知道具体工厂的名称就可以得到所需要的产品，无需知道产品的具体创建过程。 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无需对原工厂进行修改，满足开闭原则。 缺点： 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 2.3 抽象工厂模式工厂方法模式只考虑生产同级别产品，但是在现实生活中许多工厂是综合性的工厂，能生产多种类产品。 抽象工厂模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无需指定所要产品的具体类就能得到同族的不同级别的产品的模式接口。 抽象工厂模式是工厂方法模式的升级版，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 抽象工厂(Abstract Factory)：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂(Concrete Factory)：主要是实现抽象工厂中的多个抽象方法，完成具体产品创建。 抽象产品(Product)：定义了产品规范 ，描述了产品的主要特征和功能。抽象工厂模式有多个抽象产品。 具体产品(Concrete Product)：实现了抽象产品角色定义的接口，由具体工厂来创建，同具体工厂之间是多对一的关系。 优缺点： 优点：当一个产品族中多个对象被设计成在一起工作时，它能保证客户端始终只使用一个产品中的对象。 缺点：当产品族中增加一个新的产品时，所有的工作类都要进行修改。 应用场景：换肤，一整套一起换。颜色、字体、图标等。 模式扩展 简单工厂+配置文件接触耦合 加载配置文件，获取配置文件中配置的全类名，并创建该类的对象进行存储 1234567891011121314151617181920212223242526272829303132public class CoffeeFactory { //1.定义容器对象存储咖啡对象 private static HashMap&lt;String,Coffee&gt; map = new HashMap&lt;String,Coffee&gt;(); //2.加载配置文件，只需要加载一次 static { Properties p = new Properties(); InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(name:&quot;bean.propert.....&quot;) try { p.load(is); Set&lt;Object&gt; keys = p.keySet(); for (Object key:keys){ String className = p.getProperty((String) key); //通过反射技术创建对象 Class clazz = Class.forName(className); Coffee coffee = (Coffee) clazz.newInstance(); //将名称和对象存储到容器中 map.put((String)key,coffee); } } catch(IOException e) { e.printStackTrace(); } } //根据名称获取对象 public static Coffee creatCoffee(String name){ return map.get(name); } } JDK源码解析-Collection.iterator方法 抽象工厂(Abstract Factory)：提供了创建产品的接口。Collection 具体工厂(Concrete Factory)：主要是实现抽象工厂中的多个抽象方法，完成具体产品创建。ArrayList 抽象产品(Product)：定义了产品规范 ，描述了产品的主要特征和功能。iterator 具体产品(Concrete Product)：实现了抽象产品角色定义的接口，由具体工厂来创建。ArrayList$Iter Collection接口是抽象工厂类，ArrayList是具体的工厂类，Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。 抽象工厂类、抽象产品类 用的都是接口。 2.4 原型模式用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和该原型对象相同的新对象。 抽象原型类：规定了具体原型对象必须实现的clone()方法。 具体原型类：实现抽象原型类的clone()方法，它是可被复制的对象。 访问类：使用具体原型类中的clone()方法来复制新的对象。 2.5 建造者模式3. 结构型模式（7种）结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构性模式和对象结构型模式。 类结构型模式采用继承机制来组织接口和类。例如： 对象结构型模式采用组合或聚合来组合对象。例如：代理模式、 由于组合关系或聚合关系比继承关系耦合度低，满足合成复用原则，所以对象结构型模式比类结构型模式有更大的灵活性。 3.1 代理模式 Proxy由于某些原因需要给某对象提供一个代理以控制该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 静态代理：编译期生成 动态代理：运行时生成，JDK代理(接口代理)、CGLIB代理 代理模式分为三种角色： 抽象主题类(Subject)：通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题类(Real Subject)：实现了抽象主题中的具体业务，是代理对象锁代表的真实对象，是最终要引用的对象。 代理类(Proxy)：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 3.2 适配器模式 Adapter实际应用场景： 实际项目中的引用，行情服务从一个服务商切换到另一个服务商，例如：行情数据、个股详情数据 定义：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的哪些类能一起工作。 适配器模式分为类适配器模式和对象适配器模式： 类适配器模式：耦合度比比对象适配器高，较少使用。 对象适配器模式：使用较多。 适配器模式包含一下主要角色： 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 类适配器： 违背了合成复用原则，类适配器是客户类有一个接口规范的情况下可用，反之不可用。 对象适配器：对象适配器模式可采用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。 接口适配器：当不希望实现一个接口中的所有的方法时，可以创建一个抽象类Adapter，实现所有方法，而此时我们只需继承该抽象类即可。 3.3桥接模式3.4 装饰者模式3.5 外观模式3.6享元模式3.7 组合模式4. 行为型模式（11种）4.1 模版方法模式4.2 策略模式4.3 命令模式4.4 责任链模式4.5 状态模式4.6 观察者模式4.7中介者模式4.8 迭代器模式4.9 访问者模式4.10 备忘录模式4.11 解释器模式5. 小结","link":"/2021/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"categories":[],"pages":[]}