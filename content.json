{"posts":[{"title":"","text":"鸿蒙面试0. 鸿蒙系统0.1 OpenHarmony0.2 HarmonyOS####0.2.1 HarmonyOS应用多模块开发 怎么引入另外一个模块 ####0.2.1 HarmonyOS应用与Flutter交互 ####请介绍一下鸿蒙操作系统的特点和优势 分布式技术：鸿蒙操作系统采用分布式技术，能够将不同的设备连接在一起，实现设备之间的数据共享和协同工作。 微内核架构：鸿蒙操作系统采用微内核架构，具有更高的安全性和稳定性。全场景支持：鸿蒙操作系统支持多种设备，包括手机、平板、智能穿戴设备、智能家居、车载等，实现了全场景覆盖。 开放生态：鸿蒙操作系统是一个开放的生态系统，支持第三方应用开发者加入，为用户提供更多的应用和服务。 流畅体验：鸿蒙操作系统采用了先进的技术，能够提供更加流畅的用户体验，包括更快的启动速度、更低的内存占用等。 ####请简述华为鸿蒙操作系统的特点。 鸿蒙操作系统是华为开发的全场景分布式操作系统，支持多种设备，具有低延迟、高性能、安全性强等特点。鸿蒙系统中的“一次开发，多端部署”是什么意思？ 开发者只需编写一次代码，就能在手机、平板、手表、电视、汽车等多类型设备上运行，得益于鸿蒙OS统一的开发环境、语言与API，以及对设备能力的抽象封装。问题：鸿蒙操作系统支持哪些编程语言？答案：鸿蒙操作系统主要支持Java、C/C++以及JavaScript等编程语言进行应用开发 1. ArkTS语言基础####JS/TS/Arkts区别？ 包含，js&lt;ts&lt;arkts 但是arkts有些ts js语法是不能用的。 ####ArkTS文件和TS文件的区别 ArkTS基于并兼容了TS语法，继承了TS的所有特性，当前，ArkTS在TS的基础上主要扩展了声明式UI能力，让开发者能够以更简洁、更自然的方式开发高性能应用。推荐用ArtTS开发UI相关内容，TS可以用来开发业务逻辑相关内容。 #####如果别人传过来的数据不知道类型能不能用any？怎么办？ ts里包裹，log看日志拆结构。 ####在ArkTS中如何处理异步操作？ ArkTS支持使用async和await关键字来处理异步操作。这些关键字使异步代码看起来像同步代码，并且更加易读 例如，使用任务池API可以创建后台任务，并将这些任务放入任务队列中等待执行。任务池会根据系统的负载情况自动调度任务到不同的工作线程上执行，从而降低整体资源的消耗并提高系统的整体性能。 请注意，由于ArkTS和鸿蒙系统都在不断演进和发展中，因此以上信息可能会随着版本更新而发生变化。建议在实际面试前查阅最新的官方文档和资料以获取最准确的信息。 ArkTS中的并发和多线程处理是如何实现的？ArkTS本身作为UI开发语言，主要关注于用户界面的构建和渲染，并不直接提供并发和多线程处理的API。然而，鸿蒙系统提供了任务池（TaskPool）等并发工具，允许开发者在后台执行多线程任务。开发者可以在ArkTS中通过调用这些系统提供的API来实现并发和多线程处理。 ArkTS 的主要特点有哪些 响应式系统：支持数据驱动视图更新。 类型安全：基于 TypeScript 提供静态类型检查。 组件化开发：支持声明式的 UI 定义和复用。 跨平台：能够编译为 HarmonyOS 上运行的应用程序代码。 高性能：通过预编译和高效的运行时引擎提高应用性能。 ####App、HAP、HAR的关系 App是个上架概念，多个HAP打包一起上架。 HAP是可以独立运行、分发的，HAP不是复用的，复用的应该是HAR。 HAR是静态共享包，每个模块依赖的话都会打包到HAP里。 ####har和hsp区别？只有体积大小的区别吗？ 解决体积膨胀的问题，har是安装包直接安装在进程里 应用、元服务和卡片是什么关系 元服务也是一种应用，只不过没有图标，可以执行免安装拉起而已。 应用和元服务，不能共享包名，它们得分别打包，元服务和应用之间是分割开的，也不能共享entry模块 应用与元服务都可以有卡片，而不是某一方特有的。 元服务的卡片在手机上的入口，就表现为桌面卡片；在桌面长按任何一张已经添加的卡片，比如：图库和备忘录，在弹出来的菜单中选择“卡片中心”，进入卡片中心页面，可以找到卡片来添加到桌面。带下划线的桌面图标的应用表示存在服务卡片。 2. ArkUI：声明式UI###2.1 ArkUI基础 2.1.1 生命周期: 组件、页面、UIAbilitya.组件生命周期：被@Component装饰的自定义组件的生命周期 aboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。通常在该生命周期发送请求获取数据。 aboutToDisappear：在自定义组件即将析构销毁时执行。 b.页面生命周期：被@Entry装饰的组件生命周期 onPageShow：页面每次显示时触发。 onPageHide：页面每次隐藏时触发（通常是路由跳转到其他页面了）。 onBackPress：当用户点击返回按钮时时触发（是手机底部操作栏的返回按钮，不是顶部的路由返回按钮）。 c.UIAbility生命周期：State模型生命周期 onCreate：Create状态为在应用加载过程中，UIAbility实例创建完成时触发，系统会调用onCreate()回调。可以在该回调中进行应用初始化操作，例如变量定义资源加载等，用于后续的UI界面展示。 onForeground：在UIAbility的UI界面可见之前，如UIAbility切换至前台时触发。可以在onForeground()回调中申请系统需要的资源，或者重新申请在onBackground()中释放的资源。 onBackground：在UIAbility的UI界面完全不可见之后，如UIAbility切换至后台时候触发。可以在onBackground()回调中释放UI界面不可见时无用的资源，或者在此回调中执行较为耗时的操作，例如状态保存等。 onDestroy：在UIAbility实例销毁时触发。可以在onDestroy()回调中进行系统资源的释放、数据的保存等操作。 UIAbility的启动模式UIAbility的启动模式是指在启动UIAbility实例时所采用的不同呈现状态和行为方式。HarmonyOS为UIAbility提供了多种启动模式，以满足不同业务场景的需求。这些启动模式包括： Singleton（单实例模式） ：这是默认情况下的启动模式。当应用进程中该类型的UIAbility实例已经存在时，系统会复用该实例，而不是创建新的实例。这意味着每次调用startAbility()方法时，如果相同类型的UIAbility实例已经存在，则不会进入onCreate()和onWindowStageCreate()生命周期回调，而只会进入onNewWant()回调。这种模式下，UIAbility在任务列表里只会有一个历史任务。 Multiton（多实例模式） ：在这种模式下，可以多次创建UIAbility实例。但是，每次创建新的实例之前，之前的实例都会被销毁。因此，在任务列表里也只能看到一个历史任务。每次创建新的实例时，都会重新走一遍UIAbility的生命周期方法。 Standard（标准实例模式） ：这也是一种多实例模式。与Multiton不同的是，创建新的实例时不会销毁之前的实例，所以在任务列表里可以看到多个实例。这意味着每次点击都会创建新的实例，并且每个实例都有自己的生命周期。 Specified（指定实例模式） ：这种启动模式需要指定一个ID。在创建UIAbility时，系统会先判断任务列表里是否存在指定ID的UIAbility实例。如果存在，则不会创建新的实例；如果不存在，则会创建新的实例。 2.1.2 装饰器#####@builder和@builderParam装饰器的作用？ #####父子组件双向数据绑定: 使用 @State 和 @Link 进行数据双向绑定 说一下@state、@Link、@Builder、@Provide和@Consume的区别#####@builder和@builderParam装饰器 样式相关装饰器@Styles和@Extend的使用和区别容器组件滚动可滚动组件：Scroll、List、Grid等容器组件可以滚动。 使用过哪些原生组件，布局容器和基本控件，可以针对提一些问题。#####自定义组件和子组件 生命周期：每个自定义组件都有自己的生命周期，但并非所有生命周期函数都对所有组件有效。自定义组件生命周期：每一个自定义组件@Component都有自己的生命周期，但注意 Page 相关的周期只有 @Entry 的页面入口有自定义组件生命周期时机：aboutToAppear()在build函数之前执行。用于组件显示前的准备工作。 2.2 ArkUI动画如何在 ArkTS 中实现动画效果？ArkTS 可以使用Animated组件和动画属性来实现动画效果。例如，可以使用Animated.Value来创建一个动画值，然后通过设置组件的属性如width、height、opacity等与动画值进行绑定，再使用Animated.timing、Animated.spring等方法来创建动画效果。 2.2 状态管理都用过哪些装饰器？@State @Watch @Link @Prop 等等，着重介绍如何使用，什么特性即可。 常用的装饰器有哪些。装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，@Component表示自定义组件，@Entry表示该自定义组件为入口组件，@State表示组件中的状态变量，状态变量变化会触发UI刷新。 ​ 2.2.2 状态存储localStorage和appStorage的区别 localStorage和appStorage的区别，和对应的装饰器 localStorage是页面级数据存储，在页面中创建实例，组件中使用@LocalStorageLink和@LocalStorageProp装饰器修饰对应的状态变量，绑定对应的组件使用比状态属性更灵活 appStorage是进程级数据存储，进程启动时自动创建了唯一实例，在各个页面组件中@StorageProp和@StorageLink装饰器修饰对应的状态变量。 localStorage和appStorage数据存取都是在主线程进行的，且api只提供了同步接口，存取数据时要注意数据的大小。 如何在 ArkTS 中实现数据的本地存储？ArkTS 可以使用@StorageLink装饰器来实现数据的本地存储绑定。例如：@StorageLink(‘key’) value，其中key是存储的键名，value是绑定的数据变量。通过这种方式，数据的变化会自动同步到本地存储，并且在应用启动时可以从本地存储中恢复数据。 首选项异步存储在并发场景上的注意事项首选项preference提供了异步存储接口，首选项的数据存储维度分为内存和沙盒，为避免内存过大导致报警，要控制首选项数据存储的数据，可以使用await来控制并发存储的问题 用户首选项是线程安全的吗首选项是线程安全的，所以多线程访问可以保证数据一致性，但只支持同进程，不支持多进程。 #####首选项底层逻辑？ 提供key value形式的api。系统静态容器提供 pf实例对象在内存中，对应获取沙箱中数据的文件。 注意轻量级，key不为空且长度不超过80字节，value若为string长度不超过8192字节。 ###2.3 UI布局 2.3.1常见布局方式#####flex导致二次布局的原因，以及调研的经历 flex中flexgrow=1时，子组件宽度和大于flex的宽度时，页面渲染后，会调整子组件宽度使之宽度和等于flex的宽度，造成二次布局渲染 flex中flexshrink=1时，子组件宽度和小于flex的宽度时，页面渲染后，也会调整子组件宽度使之宽度和等于flex的宽度，造成二次布局渲染 #####页面布局上的性能和内存上的注意事项 1、使用row/column+layoutweight代替flex容器使用 2、scroll嵌套list/grid容器时，要设置容器的宽高，数组数据渲染尽量使用lazyforeach渲染item 3、组件的显隐设置，要使用if语句来判断，避免使用visibility 4、list/grid容器要根据具体场景来使用cachecount，避免卡顿 2.3.2一多适配开发一套代码，UI同时适配手机，折叠屏和平板，怎么实现媒体查询 #####如何在 ArkTS 中实现响应式布局？ ArkTS 可以使用 Flex 布局和响应式属性来实现响应式布局。例如，可以使用Flex组件来创建弹性布局容器，并设置justifyContent、alignItems等属性来调整子元素的排列方式。同时，可以使用响应式属性如width、height、margin等，根据不同的设备尺寸和屏幕方向进行自适应调整。解释一下 ArkTS 中的Stack组件的作用。Stack组件用于创建堆叠布局，可以将多个子组件按照指定的顺序堆叠在一起。可以设置alignment属性来调整子组件在堆叠方向上的对齐方式，还可以设置clipToBounds属性来控制子组件是否超出父容器的边界进行裁剪。 ####flex为什么有性能问题？flex为什么影响性能？ flex会二次重绘，因为flexShrink ####用过哪些组件？ row column stack list swiper RelativeContainer等等 ##3. 通信与调度 ###3.1 Ability交互 三方应用调用系统应用，对于ability的交互和传值有什么限制？除了数据大小方面 重点介绍自己对ability的理解，描述显式want和隐式want的区别，带入到对应面试项目中场景来 启动应用内的UIAbility 启动应用内的UIAbility并获取返回结果 启动其他应用的UIAbility 启动其他应用的UIAbility并获取返回结果 启动UIAbility的指定页面 显式Want启动：在want参数中需要设置该应用bundleName和abilityName，当需要拉起某个明确的UIAbility时，通常使用显式Want启动方式。 隐式Want启动：不明确指出要启动哪一个UIAbility，在调用startAbility()方法时，其入参want中指定了一系列的entities字段（表示目标UIAbility额外的类别信息，如浏览器、视频播放器）和actions字段（表示要执行的通用操作，如查看、分享、应用详情等）等参数信息，然后由系统去分析want，并帮助找到合适的UIAbility来启动。 ###3.2 页面通信 ###3.3 组件通信 ###3.4 多线程通信 3.4 路由跳转页面的跳转和数据传递组件间怎么通信，传递数据 ####组件通信方式有哪些？ H5页面如何与ArkTS交互 ####a ability拉b ability类型会不会丢失？ 会丢 navigation和router区别，优缺点 #####页面栈 页面栈数量：每调用一次router.pushUrl()方法，默认情况下，页面栈数量会增加1。鸿蒙系统对页面栈的数量有限制，通常是32个。页面跳转销毁：router.replaceUrl()方法可以跳转到一个新页面，并销毁当前页面。 作者：维维喂喂微微 https://www.bilibili.com/read/cv33829990/ 出处：bilibili ##4. 网络与多线程 ###4.1 网络 网络请求需要添加什么权限，在哪里添加####谈谈 ArkTS 中数据请求的方法有哪些？ 可以使用原生的 JavaScript 中的fetch或axios等库来进行网络请求获取数据。在 ArkTS 中，可以在函数或组件的方法中调用这些库进行数据请求，并将获取的数据更新到组件的状态中，从而触发界面的更新。 ####网络相关的三方库有哪些 网络相关的三方库有Axios、httpclient、okdownload等，具体分类可以参考三四方库网络分类。 ####如何监听网络变化 在网络连接管理模块中通过on(‘netCapabilitiesChange’)订阅网络能力变化事件，即可监听网络变化。如何获取网络类型：Wi-Fi，3G，4G，5G等先通过getNetCapabilities去获取网络的类型，判断默认网络是WIFI还是蜂窝。 如果是Wi-Fi，则直接确认网络类型是Wi-Fi。如果是在蜂窝连接情况下，可以调用radio.getSignalInformation获取指定SIM卡槽对应的注册网络信号强度信息列表，返回SignalInformation对象的数组，其中，返回的signalType代表网络类型NetworkType，signalType的值对应网络类型如下： GSM：2GCDMA：电信2GWCDMA：3GTDSCDMA：3GLTE：4GNR：5G #####项目中接口请求的数据，需要进行缓存吗？鸿蒙化处理过程 根据自己项目中的业务逻辑描述，MapKit需要将当前屏幕中展示的6个瓦片数据图片缓存到沙盒中，杀掉进程后，断开网络，打开app会展示缓存的数据瓦片。 ###4.2 多线程 如何判断是否为主线程####有哪些创建线程的方式 在ArkTS中使用Worker创建线程，Worker线程在主线程中创建，与主线程相互独立，但不能直接操作UI，最多可以创建64个Worker线程。在ArkTS中使用任务池（TaskPool）创建线程任务。通过NAPI机制，在C代码中使用标准的线程API创建线程。 ####TaskPool和Worker的异同点 不同点：两者是不同颗粒度的并发API，Worker更像Thread或者Service维度，Task就是单一任务维度。同时TaskPool简化开发者开发并发程序，支持优先级和取消，并且通过统一管理节省系统资源优化调度。相同点：在JS相关的线程间交互上，二者本质都是内存隔离模型，参数与范围值的限制是一致的，也有开销。 Worker和TaskPool的线程数量是否有限制TaskPool内部会动态调整线程个数，不支持设置数量，只需要往线程池中抛任务，确保高优先级任务的及时执行。 Worker的线程个数最多64个，如果Worker超过规定个数，会创建失败。 在使用时，TaskPool与Worker两者独立，不相互影响，因此Worker在达到上限数量时，不会影响TaskPool。Worker是固定数量，当前是64个。TaskPool线程池的数量会根据硬件条件、任务负载等情况动态调整。 ####在多线程并发场景中，如何实现安全访问同一块共享内存 可以使用共享对象SharedArrayBuffer实现。SharedArrayBuffer对象存储的数据在同时被修改时，需要通过Atomics原子操作保证其同步性，即下个操作开始之前务必需要等到上个操作已经结束。如何实现多线程数据共享由于ArkTS是单线程模型，内存隔离，因此大部分普通对象跨线程均采用序列化方式，通过ArrayBuffer的转移传输和SharedArrayBuffer进行共享。 ####多线程怎么保证并发一致性？ 队列，同步锁 ####多进程sp怎么保证一致性？ 分为两种情况，读，不需要处理。写，需要加锁。 ####主线程上的数据对象序列化后传到子线程，子线程改变了对象的属性值，主线程跟着一起改变吗 不会变 ####子线程和主线程的消息传递 目前鸿蒙线程间通信使用emitter ####promise和callback的区别？ promise没有解决回调的问题，因为then本身也是回调，但他规范一套异步的规范，符合promise a+规范的都是promise，这个对于写各种库的人来说规范了他们的接口格式，开发者在使用各种接口的时候不用考虑这个传啥回调那个传啥回调 ####promise.then是在哪个线程里？ then里面的处理是在主线程。 ####.then调用和await调用的区别 当使用Promise进行异步操作时，可以使用.then和await两种方式来调用异步接口；.then调用不阻塞当前线程，异步回调结束后会直接走到then中，await会等待当前异步方法执行结束才会继续往下执行。 ####taskpool开启子线程和promise的区别 taskpool开辟子线程能够充分利用现代手机设备多核配置，提高程序的并发性和运行效率；Promise是在当前线程进行异步调用，可以避免阻塞主线程，保证程序的响应速度，提高用户体验； 具体使用场景：当需要执行I/O操作时，使用异步操作比使用线程+同步I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。当需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行时，建议使用子线程操作。 ####两个按钮分别调用一个异步async代码，里面有多个await，他们会不会交叉进行？ 会交叉。async和await是promise的语法糖，相当于将当前执行栈的任务全部包含到then里面 ####worker 和 taskpool的区别？ 前者是子线程并发处理，后者是异步批量处理。worker 最多只有8个。taskpool处理超过三分钟就会失效。 ####鸿蒙系统http在接口请求时，系统本身应该是开启子线程来请求，那么为什么在项目中还要使用taskpool开辟子线程呢 鸿蒙底层的http请求实现是在子线程中进行的，但针对于请求参数的编码与返回值的解析，这部分需要花费时间来处理的业务逻辑，还是建议使用taskpool开辟子线程来处理 5.ArkWeb：与H5交互webview交互，传递数据h5跟arkts怎么交互？runJavaScript（） arkts-》H5 javaScriptProxy() 和 registerjavaScriptProxy() H5-》arkts 拦截url 过滤 createWebMessagePorts postMessage onMessageEvent 数据通道 #####H5页面如何与ArkTS交互 通过对javaScriptProxy和runJavaScript封装，实现JSBridge通信方案。使用Web组件javaScriptProxy将原生侧接口注入到H5的window对象上，通过runJavaScript接口执行JS脚本到H5中，并在回调中获取脚本执行结果 ##7.鸿蒙Native: NAPI ####从介绍中延伸出har和下沉到系统的so的优缺点 har分为静态分享库和动态分享库，静态分享库生成har包集成到应用中，应用运行时直接加载到进程中，动态分享库生成hsp和har包，har集成到应用中，hsp需要安装到手机设备中，应用运行时，har直接加载到进程中，但hsp需要业务调用才会加载； so是c++和arkts的混编，arkts开发完成后，编译生成对应的js文件，使用华为工具将js文件和NAPI混编为so； 目前api10和api11不支持har包下沉到系统称为预置SDK，仅支持so。 8. 工具链如何使用ohpm引入三四方库 ##9.性能优化 如何优化 ArkTS 组件的性能 避免不必要的重新渲染：使用@Watch装饰器来监听数据变化，只有当相关数据发生变化时才进行组件的重新渲染。 合理使用列表渲染：对于大量数据的列表，可以使用ForEach组件来提高性能。 减少不必要的计算：避免在组件的build方法中进行复杂的计算，尽量将计算提前到数据准备阶段。 ####在 ArkTS 开发中，有哪些方法可以提高应用的性能？ 答案：可以通过优化数据结构、避免不必要的计算、合理使用缓存、减少页面的重绘和回流等方式提高应用性能。在界面开发中，尽量使用简单的布局和组件，避免过度嵌套。 ####解释一下 ArkTS 中的LazyForEach组件的作用 LazyForEach组件用于在列表渲染时实现懒加载。当列表中的项很多时，LazyForEach可以只渲染可见区域的项，当用户滚动列表时，再逐步加载其他项，从而提高性能和减少内存占用。 ####list使用有什么坑？渲染逻辑？ list默认会把listitem全部都渲染出来，数据量大会对内存造成压力。LazyForEach，只加载可见区域。 ####页面性能内存优化？ 性能和内存是两个指标，有时候追求性能，就需要做缓存处理，吃内存。 页面内存优化，主要在减少缓存的处理。 性能优化，主要在少嵌套，减少动态渲染的频率。 装饰器,组件间通信,性能优化,数据持久化存取#####lazyforeach使用相关的 10. 实际项目中遇到的疑难问题与解决方法#####遇到过什么问题 分享一个你在使用 ArkTS 开发过程中遇到并解决的实际问题","link":"/2025/06/26/%E9%B8%BF%E8%92%99%E9%9D%A2%E8%AF%95/"}],"tags":[],"categories":[],"pages":[]}