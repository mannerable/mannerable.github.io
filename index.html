<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>The Bit Garden</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="The Bit Garden"><meta name="msapplication-TileImage" content="/img/bitg.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="The Bit Garden"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="The Bit Garden"><meta property="og:url" content="http://taofei.tech/"><meta property="og:site_name" content="The Bit Garden"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://taofei.tech/img/og_image.png"><meta property="article:author" content="TaoFei"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://taofei.tech/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://taofei.tech"},"headline":"The Bit Garden","image":["http://taofei.tech/img/og_image.png"],"author":{"@type":"Person","name":"TaoFei"},"publisher":{"@type":"Organization","name":"The Bit Garden","logo":{"@type":"ImageObject","url":"http://taofei.tech/img/bitg.png"}},"description":""}</script><link rel="icon" href="/img/bitg.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/bitg.png" alt="The Bit Garden" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-12T15:20:10.000Z" title="2025/5/12 23:20:10">2025-05-12</time>发表</span><span class="level-item"><time dateTime="2025-06-28T16:29:19.190Z" title="2025/6/29 00:29:19">2025-06-29</time>更新</span><span class="level-item">42 分钟读完 (大约6318个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/12/%E9%B8%BF%E8%92%99%E9%9D%A2%E8%AF%95/">鸿蒙面试笔记</a></p><div class="content"><h2 id="0-鸿蒙系统"><a href="#0-鸿蒙系统" class="headerlink" title="0. 鸿蒙系统"></a>0. 鸿蒙系统</h2><h5 id="请介绍一下鸿蒙操作系统的特点和优势"><a href="#请介绍一下鸿蒙操作系统的特点和优势" class="headerlink" title="请介绍一下鸿蒙操作系统的特点和优势"></a>请介绍一下鸿蒙操作系统的特点和优势</h5><ul>
<li>分布式技术：鸿蒙操作系统采用分布式技术，能够将不同的设备连接在一起，实现设备之间的数据共享和协同工作。</li>
<li>微内核架构：鸿蒙操作系统采用微内核架构，具有更高的安全性和稳定性。全场景支持：鸿蒙操作系统支持多种设备，包括手机、平板、智能穿戴设备、智能家居、车载等，实现了全场景覆盖。</li>
<li>开放生态：鸿蒙操作系统是一个开放的生态系统，支持第三方应用开发者加入，为用户提供更多的应用和服务。</li>
<li>流畅体验：鸿蒙操作系统采用了先进的技术，能够提供更加流畅的用户体验，包括更快的启动速度、更低的内存占用等。</li>
</ul>
<h3 id="0-1-OpenHarmony"><a href="#0-1-OpenHarmony" class="headerlink" title="0.1 OpenHarmony"></a>0.1 OpenHarmony</h3><p><strong>一、核心定位与性质</strong></p>
<table>
<thead>
<tr>
<th>‌<strong>维度</strong>‌</th>
<th>‌<strong>OpenHarmony</strong>‌</th>
<th>‌<strong>HarmonyOS</strong>‌</th>
</tr>
</thead>
<tbody><tr>
<td>‌<strong>性质</strong>‌</td>
<td>开源操作系统（开放原子开源基金会运营）</td>
<td>华为基于 OpenHarmony 开发的闭源商用系统</td>
</tr>
<tr>
<td>‌<strong>目标</strong>‌</td>
<td>构建全场景分布式操作系统底座，全行业可用</td>
<td>为华为设备提供专属优化，构建商业生态</td>
</tr>
<tr>
<td>‌<strong>开源协议</strong>‌</td>
<td>Apache 2.0（允许二次开发与商用）</td>
<td>闭源，仅华为设备使用</td>
</tr>
</tbody></table>
<p><strong>二、技术架构差异</strong></p>
<table>
<thead>
<tr>
<th><strong>能力</strong>‌</th>
<th>‌<strong>OpenHarmony</strong>‌</th>
<th>‌<strong>HarmonyOS</strong>‌</th>
</tr>
</thead>
<tbody><tr>
<td>‌<strong>内核支持</strong>‌</td>
<td>多内核设计（Linux&#x2F;LiteOS），支持轻量至标准系统 913</td>
<td>继承 OpenHarmony 内核，深度优化华为硬件 56</td>
</tr>
<tr>
<td>‌<strong>分布式能力</strong>‌</td>
<td>提供基础分布式框架（软总线&#x2F;数据管理）913</td>
<td>增强分布式协同（如超级终端一拉即连）612</td>
</tr>
<tr>
<td>‌<strong>安卓兼容性</strong>‌</td>
<td>‌<strong>不兼容</strong>‌安卓 APK 26</td>
<td>HarmonyOS NEXT（5.0+）‌<strong>移除安卓兼容层</strong>‌，仅支持原生鸿蒙应用 613</td>
</tr>
<tr>
<td>‌<strong>闭源组件</strong>‌</td>
<td>无</td>
<td>集成 HMS Core、方舟编译器等专有技术</td>
</tr>
</tbody></table>
<h3 id="0-2-HarmonyOS"><a href="#0-2-HarmonyOS" class="headerlink" title="0.2 HarmonyOS"></a>0.2 HarmonyOS</h3><h5 id="请简述华为鸿蒙操作系统的特点。"><a href="#请简述华为鸿蒙操作系统的特点。" class="headerlink" title="请简述华为鸿蒙操作系统的特点。"></a>请简述华为鸿蒙操作系统的特点。</h5><p>鸿蒙操作系统是华为开发的全场景分布式操作系统，支持多种设备，具有低延迟、高性能、安全性强等特点。</p>
<h5 id="鸿蒙系统中的“一次开发，多端部署”是什么意思？"><a href="#鸿蒙系统中的“一次开发，多端部署”是什么意思？" class="headerlink" title="鸿蒙系统中的“一次开发，多端部署”是什么意思？"></a>鸿蒙系统中的“一次开发，多端部署”是什么意思？</h5><p>开发者只需编写一次代码，就能在手机、平板、手表、电视、汽车等多类型设备上运行，得益于鸿蒙 OS 统一的开发环境、语言与 API，以及对设备能力的抽象封装。</p>
<h5 id="鸿蒙操作系统支持哪些编程语言？"><a href="#鸿蒙操作系统支持哪些编程语言？" class="headerlink" title="鸿蒙操作系统支持哪些编程语言？"></a>鸿蒙操作系统支持哪些编程语言？</h5><p>鸿蒙操作系统主要支持 Java、C&#x2F;C++以及 JavaScript 等编程语言进行应用开发</p>
<h4 id="0-2-1-HarmonyOS-应用多模块开发"><a href="#0-2-1-HarmonyOS-应用多模块开发" class="headerlink" title="0.2.1 HarmonyOS 应用多模块开发"></a>0.2.1 HarmonyOS 应用多模块开发</h4><h5 id="App、HAP、HAR-的关系"><a href="#App、HAP、HAR-的关系" class="headerlink" title="App、HAP、HAR 的关系"></a>App、HAP、HAR 的关系</h5><ul>
<li>App 是个上架概念，多个 HAP 打包一起上架。</li>
<li>HAP 是可以独立运行、分发的，HAP 不是复用的，复用的应该是 HAR。</li>
<li>HAR 是静态共享包，每个模块依赖的话都会打包到 HAP 里。</li>
</ul>
<p><img src="/image/har&hsp%E6%A8%A1%E5%9D%97.png" alt="har&amp;hsp模块"></p>
<h5 id="har-和-hsp-区别？只有体积大小的区别吗？"><a href="#har-和-hsp-区别？只有体积大小的区别吗？" class="headerlink" title="har 和 hsp 区别？只有体积大小的区别吗？"></a>har 和 hsp 区别？只有体积大小的区别吗？</h5><p>解决体积膨胀的问题，har 是安装包直接安装在进程里</p>
<h4 id="0-2-2-HarmonyOS-应用与-Flutter-交互"><a href="#0-2-2-HarmonyOS-应用与-Flutter-交互" class="headerlink" title="0.2.2 HarmonyOS 应用与 Flutter 交互"></a>0.2.2 HarmonyOS 应用与 Flutter 交互</h4><p>要想鸿蒙支持flutter需要flutter sdk对应鸿蒙版本兼容，Gitcode中有维护<a target="_blank" rel="noopener" href="https://gitcode.com/openharmony-tpc/flutter_flutter">flutter_flutter</a>，具体配置可以参考readme。另外，flutter只是一个UI框架，但凡涉及到与硬件或者操作系统相关的操作，例如：获取相册图片、获取文件、连接蓝牙等，都需要利用三方库或自己实现flutter与原生的交互。一般三方库如果有对应Android和iOS的实现，没有鸿蒙的实现那么就需要自己通过methodChanel实现对应的鸿蒙平台实现<a target="_blank" rel="noopener" href="https://gitcode.com/openharmony-tpc/flutter_samples/blob/master/ohos/docs/07_plugin/ohos%E5%B9%B3%E5%8F%B0%E9%80%82%E9%85%8Dflutter%E4%B8%89%E6%96%B9%E5%BA%93%E6%8C%87%E5%AF%BC.md#%E4%B8%89%E5%88%9B%E5%BB%BA%E6%8F%92%E4%BB%B6%E7%9A%84ohos%E6%A8%A1%E5%9D%97">三方库进行鸿蒙化</a>。</p>
<h2 id="1-ArkTS-语言基础"><a href="#1-ArkTS-语言基础" class="headerlink" title="1. ArkTS 语言基础"></a>1. ArkTS 语言基础</h2><h5 id="JS-TS-Arkts-区别？"><a href="#JS-TS-Arkts-区别？" class="headerlink" title="JS&#x2F;TS&#x2F;Arkts 区别？"></a>JS&#x2F;TS&#x2F;Arkts 区别？</h5><p>包含，js&lt;ts&lt;arkts 但是 arkts 有些 ts js 语法是不能用的。</p>
<h5 id="ArkTS-文件和-TS-文件的区别"><a href="#ArkTS-文件和-TS-文件的区别" class="headerlink" title="ArkTS 文件和 TS 文件的区别"></a>ArkTS 文件和 TS 文件的区别</h5><p>ArkTS 基于并兼容了 TS 语法，继承了 TS 的所有特性，当前，ArkTS 在 TS 的基础上主要扩展了声明式 UI 能力，让开发者能够以更简洁、更自然的方式开发高性能应用。推荐用 ArtTS 开发 UI 相关内容，TS 可以用来开发业务逻辑相关内容。</p>
<h5 id="如果别人传过来的数据不知道类型能不能用-any？怎么办？"><a href="#如果别人传过来的数据不知道类型能不能用-any？怎么办？" class="headerlink" title="如果别人传过来的数据不知道类型能不能用 any？怎么办？"></a>如果别人传过来的数据不知道类型能不能用 any？怎么办？</h5><p>ts 里包裹，log 看日志拆结构。</p>
<h5 id="在-ArkTS-中如何处理异步操作？"><a href="#在-ArkTS-中如何处理异步操作？" class="headerlink" title="在 ArkTS 中如何处理异步操作？"></a>在 ArkTS 中如何处理异步操作？</h5><p>ArkTS 支持使用 async 和 await 关键字来处理异步操作。这些关键字使异步代码看起来像同步代码，并且更加易读</p>
<p>例如，使用任务池 API 可以创建后台任务，并将这些任务放入任务队列中等待执行。任务池会根据系统的负载情况自动调度任务到不同的工作线程上执行，从而降低整体资源的消耗并提高系统的整体性能。</p>
<p>请注意，由于 ArkTS 和鸿蒙系统都在不断演进和发展中，因此以上信息可能会随着版本更新而发生变化。建议在实际面试前查阅最新的官方文档和资料以获取最准确的信息。</p>
<h5 id="ArkTS-中的并发和多线程处理是如何实现的？"><a href="#ArkTS-中的并发和多线程处理是如何实现的？" class="headerlink" title="ArkTS 中的并发和多线程处理是如何实现的？"></a>ArkTS 中的并发和多线程处理是如何实现的？</h5><p>ArkTS 本身作为 UI 开发语言，主要关注于用户界面的构建和渲染，并不直接提供并发和多线程处理的 API。然而，鸿蒙系统提供了任务池（TaskPool）等并发工具，允许开发者在后台执行多线程任务。开发者可以在 ArkTS 中通过调用这些系统提供的 API 来实现并发和多线程处理。</p>
<h5 id="ArkTS-的主要特点有哪些"><a href="#ArkTS-的主要特点有哪些" class="headerlink" title="ArkTS 的主要特点有哪些"></a>ArkTS 的主要特点有哪些</h5><ul>
<li>响应式系统：支持数据驱动视图更新。</li>
<li>类型安全：基于 TypeScript 提供静态类型检查。</li>
<li>组件化开发：支持声明式的 UI 定义和复用。</li>
<li>跨平台：能够编译为 HarmonyOS 上运行的应用程序代码。</li>
<li>高性能：通过预编译和高效的运行时引擎提高应用性能。</li>
</ul>
<h5 id="应用、元服务和卡片是什么关系"><a href="#应用、元服务和卡片是什么关系" class="headerlink" title="应用、元服务和卡片是什么关系"></a>应用、元服务和卡片是什么关系</h5><ul>
<li>元服务也是一种应用，只不过没有图标，可以执行免安装拉起而已。</li>
<li>应用和元服务，不能共享包名，它们得分别打包，元服务和应用之间是分割开的，也不能共享 entry 模块</li>
<li>应用与元服务都可以有卡片，而不是某一方特有的。</li>
<li>元服务的卡片在手机上的入口，就表现为桌面卡片；在桌面长按任何一张已经添加的卡片，比如：图库和备忘录，在弹出来的菜单中选择“卡片中心”，进入卡片中心页面，可以找到卡片来添加到桌面。带下划线的桌面图标的应用表示存在服务卡片。</li>
</ul>
<h2 id="2-ArkUI：声明式-UI"><a href="#2-ArkUI：声明式-UI" class="headerlink" title="2. ArkUI：声明式 UI"></a>2. ArkUI：声明式 UI</h2><p>大前端包括Android、iOS、鸿蒙、flutter等在内，在大的趋势上都逐步往声明式UI的方向发展，目前已有的声明式UI开发框架有；</p>
<ul>
<li>H5：React、Vue</li>
<li>Android：Jetpack Compose</li>
<li>iOS：SwiftUI</li>
<li>HarmonyOS：ArkUI</li>
<li>跨平台：Flutter、React Native</li>
</ul>
<h3 id="2-1-ArkUI-基础"><a href="#2-1-ArkUI-基础" class="headerlink" title="2.1 ArkUI 基础"></a>2.1 ArkUI 基础</h3><h4 id="2-1-1-生命周期-组件、页面、UIAbility"><a href="#2-1-1-生命周期-组件、页面、UIAbility" class="headerlink" title="2.1.1 生命周期: 组件、页面、UIAbility"></a>2.1.1 生命周期: 组件、页面、UIAbility</h4><h5 id="a-组件生命周期：被-Component-装饰的自定义组件的生命周期"><a href="#a-组件生命周期：被-Component-装饰的自定义组件的生命周期" class="headerlink" title="a.组件生命周期：被@Component 装饰的自定义组件的生命周期"></a>a.组件生命周期：被@Component 装饰的自定义组件的生命周期</h5><ul>
<li><code>aboutToAppear</code>：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其 build()函数之前执行。通常在该生命周期发送请求获取数据。</li>
<li><code>aboutToDisappear</code>：在自定义组件即将析构销毁时执行。</li>
</ul>
<h5 id="b-页面生命周期：被-Entry-装饰的组件生命周期"><a href="#b-页面生命周期：被-Entry-装饰的组件生命周期" class="headerlink" title="b.页面生命周期：被@Entry 装饰的组件生命周期"></a>b.页面生命周期：被@Entry 装饰的组件生命周期</h5><ul>
<li><code>onPageShow</code>：页面每次显示时触发。</li>
<li><code>onPageHide</code>：页面每次隐藏时触发（通常是路由跳转到其他页面了）。</li>
<li><code>onBackPress</code>：当用户点击返回按钮时时触发（是手机底部操作栏的返回按钮，不是顶部的路由返回按钮）。</li>
</ul>
<h5 id="c-UIAbility-生命周期：State-模型生命周期"><a href="#c-UIAbility-生命周期：State-模型生命周期" class="headerlink" title="c.UIAbility 生命周期：State 模型生命周期"></a>c.UIAbility 生命周期：State 模型生命周期</h5><ul>
<li><code>onCreate</code>：Create 状态为在应用加载过程中，UIAbility 实例创建完成时触发，系统会调用 onCreate()回调。可以在该回调中进行应用初始化操作，例如变量定义资源加载等，用于后续的 UI 界面展示。</li>
<li><code>onForeground</code>：在 UIAbility 的 UI 界面可见之前，如 UIAbility 切换至前台时触发。可以在 onForeground()回调中申请系统需要的资源，或者重新申请在 onBackground()中释放的资源。</li>
<li><code>onBackground</code>：在 UIAbility 的 UI 界面完全不可见之后，如 UIAbility 切换至后台时候触发。可以在 onBackground()回调中释放 UI 界面不可见时无用的资源，或者在此回调中执行较为耗时的操作，例如状态保存等。</li>
<li><code>onDestroy</code>：在 UIAbility 实例销毁时触发。可以在 onDestroy()回调中进行系统资源的释放、数据的保存等操作。</li>
</ul>
<h5 id="UIAbility-的启动模式"><a href="#UIAbility-的启动模式" class="headerlink" title="UIAbility 的启动模式"></a>UIAbility 的启动模式</h5><p><code>UIAbility</code> 的启动模式是指在启动<code>UIAbility</code> 实例时所采用的不同呈现状态和行为方式。HarmonyOS 为 UIAbility 提供了多种启动模式，以满足不同业务场景的需求。这些启动模式包括：</p>
<ul>
<li><code>Singleton</code>（单实例模式） ：这是默认情况下的启动模式。当应用进程中该类型的 UIAbility 实例已经存在时，系统会复用该实例，而不是创建新的实例。这意味着每次调用 startAbility()方法时，如果相同类型的 UIAbility 实例已经存在，则不会进入 onCreate()和 onWindowStageCreate()生命周期回调，而只会进入 onNewWant()回调。这种模式下，UIAbility 在任务列表里只会有一个历史任务。</li>
<li><code>Multiton</code>（多实例模式） ：在这种模式下，可以多次创建 UIAbility 实例。但是，每次创建新的实例之前，之前的实例都会被销毁。因此，在任务列表里也只能看到一个历史任务。每次创建新的实例时，都会重新走一遍 UIAbility 的生命周期方法。</li>
<li><code>Standard</code>（标准实例模式） ：这也是一种多实例模式。与 Multiton 不同的是，创建新的实例时不会销毁之前的实例，所以在任务列表里可以看到多个实例。这意味着每次点击都会创建新的实例，并且每个实例都有自己的生命周期。</li>
<li><code>Specified</code>（指定实例模式） ：这种启动模式需要指定一个 ID。在创建 UIAbility 时，系统会先判断任务列表里是否存在指定 ID 的 UIAbility 实例。如果存在，则不会创建新的实例；如果不存在，则会创建新的实例。</li>
</ul>
<h4 id="2-1-2-装饰器"><a href="#2-1-2-装饰器" class="headerlink" title="2.1.2 装饰器"></a>2.1.2 装饰器</h4><h5 id="builder-和-builderParam-装饰器的作用？"><a href="#builder-和-builderParam-装饰器的作用？" class="headerlink" title="@builder 和@builderParam 装饰器的作用？"></a>@builder 和@builderParam 装饰器的作用？</h5><ul>
<li><p><code>@Builder</code>装饰器</p>
<ul>
<li>‌<strong>作用</strong>‌：用于将重复的UI结构抽象为可复用的函数，支持组件内或全局范围的UI复用</li>
<li><strong>特性</strong>‌：<ul>
<li><strong>作用域控制</strong>‌：可以在组件内定义（私有）或全局定义（共享）</li>
<li><strong>状态访问</strong>‌：组件内通过<code>this</code>直接访问状态变量，实现动态更新</li>
<li>‌<strong>参数传递</strong>‌：支持按值传递（默认）或按引用传递（使用<code>$$</code>范式）</li>
</ul>
</li>
<li><strong>使用场景</strong>‌：减少冗余代码，例如将多个<code>Text</code>组件抽取为统一的构建函数</li>
</ul>
</li>
<li><p><code>@BuilderParam</code>装饰器</p>
<ul>
<li><strong>作用</strong>‌：用于装饰指向<code>@Builder</code>函数的变量，实现UI逻辑的动态注入，类似于“插槽”机制</li>
<li>‌<strong>特性</strong>‌：<ul>
<li>‌<strong>动态定制</strong>‌：允许父组件向子组件传递UI模板，实现功能解耦</li>
<li><strong>兼容性</strong>‌：支持ArkTS卡片（API 9+）和元服务（API 11+）</li>
<li>‌<strong>使用场景</strong>‌：通用组件开发（如列表、选项卡），子组件的UI由使用方动态传入</li>
</ul>
</li>
</ul>
</li>
<li><p>对比与关联</p>
<ul>
<li><strong>关系</strong>‌：<code>@BuilderParam</code>是<code>@Builder</code>的扩展，用于接收外部传入的UI模板</li>
<li><strong>差异</strong>‌：<code>@Builder</code>侧重复用，<code>@BuilderParam</code>侧重动态插槽功能</li>
</ul>
</li>
<li><pre><code class="language-typescript">// @Builder示例（组件内复用）
@Component
struct MyComponent &#123;
  @State count: number = 0;
  
  @Builder CounterUI() &#123;
    Row() &#123;
      Button(&#39;+&#39;).onClick(() =&gt; this.count++);
      Text(`Count: $&#123;this.count&#125;`);
    &#125;
  &#125;

  build() &#123;
    Column() &#123;
      this.CounterUI(); // 调用构建函数
    &#125;
  &#125;
&#125;

// @BuilderParam示例（动态插槽）
@Component
struct ChildComponent &#123;
  @BuilderParam customUI: () =&gt; void;

  build() &#123;
    Column() &#123;
      this.customUI(); // 渲染父组件传入的UI
    &#125;
  &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 说一下@state、@Link、@Builder、@Provide 和@Consume 的区别</span><br><span class="line"></span><br><span class="line">- @State：组件内部状态管理</span><br><span class="line">  - **作用**‌：声明组件私有状态变量，变更时自动触发‌**当前组件**‌的 UI 刷新</span><br><span class="line">  - **数据流向**‌：单向（内部驱动）</span><br><span class="line">  - ‌**典型场景**‌：管理组件自身状态（如按钮点击计数）</span><br><span class="line"></span><br><span class="line">- @Link：父子组件双向绑定</span><br><span class="line">  - ‌**作用**‌：建立父子组件间的‌**双向数据同步**‌。子组件修改数据会同步更新父组件状态</span><br><span class="line">  - ‌**数据流向**‌：双向（父子互斥）</span><br><span class="line">  - **典型场景**‌：表单控件（如子组件输入框实时修改父组件数据）</span><br><span class="line"></span><br><span class="line">- @Builder：UI 模板复用</span><br><span class="line">  - **作用**‌：封装可复用的 UI 片段，‌**非状态管理装饰器**‌</span><br><span class="line"></span><br><span class="line">  - **特性**‌：</span><br><span class="line"></span><br><span class="line">    - 支持作用域（组件内/全局）和参数传递</span><br><span class="line"></span><br><span class="line">    - 与状态变量解耦，需手动注入状态（如 `this.xxx`）</span><br><span class="line"></span><br><span class="line">    - **典型场景**‌：抽离重复布局（如统一按钮样式）</span><br><span class="line"></span><br><span class="line">      ```typescript</span><br><span class="line">      @Builder ButtonTemplate(text: string) &#123;</span><br><span class="line">        Button(text).backgroundColor(Color.Blue);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>@Provide &#x2F; @Consume：跨组件层级共享</p>
</li>
<li><p>‌<strong>作用</strong>‌：实现‌<strong>祖先组件向后代组件</strong>‌的数据穿透，支持双向同步</p>
</li>
<li><p><strong>数据流向</strong>‌：双向（跨层级传递）</p>
</li>
<li><p><strong>对比 @Link</strong>‌：</p>
</li>
</ul>
<pre><code>| 特性         | @Provide / @Consume | @Link   |
| ---------- | ------------------- | ------- |
| ‌**通信层级**‌ | 任意跨层级               | 仅父子组件   |
| ‌**代码量**‌  | 更简洁（无需逐层传递）         | 需显式传递变量 |
</code></pre>
<p>对比小结：</p>
<table>
<thead>
<tr>
<th>装饰器</th>
<th>作用范围</th>
<th>数据流向</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>@State</code></td>
<td>‌<strong>组件内部</strong>‌</td>
<td>单向</td>
<td>自身状态管理（如计数器）</td>
</tr>
<tr>
<td><code>@Link</code></td>
<td>‌<strong>父子组件</strong>‌</td>
<td>双向</td>
<td>表单控件双向同步</td>
</tr>
<tr>
<td><code>@Builder</code></td>
<td>UI 模板复用</td>
<td>-</td>
<td>封装通用 UI 结构</td>
</tr>
<tr>
<td><code>@Provide</code>&#x2F;<code>@Consume</code></td>
<td>‌<strong>跨任意层级</strong>‌</td>
<td>双向</td>
<td>全局配置（主题、语言）</td>
</tr>
</tbody></table>
<h5 id="样式相关装饰器-Styles-和-Extend-的使用和区别"><a href="#样式相关装饰器-Styles-和-Extend-的使用和区别" class="headerlink" title="样式相关装饰器@Styles 和@Extend 的使用和区别"></a>样式相关装饰器@Styles 和@Extend 的使用和区别</h5><h5 id="容器组件滚动"><a href="#容器组件滚动" class="headerlink" title="容器组件滚动"></a>容器组件滚动</h5><p>可滚动组件：Scroll、List、Grid 等容器组件可以滚动。</p>
<h5 id="使用过哪些原生组件，布局容器和基本控件，可以针对提一些问题。"><a href="#使用过哪些原生组件，布局容器和基本控件，可以针对提一些问题。" class="headerlink" title="使用过哪些原生组件，布局容器和基本控件，可以针对提一些问题。"></a>使用过哪些原生组件，布局容器和基本控件，可以针对提一些问题。</h5><h5 id="自定义组件和子组件"><a href="#自定义组件和子组件" class="headerlink" title="自定义组件和子组件"></a>自定义组件和子组件</h5><p>生命周期：每个自定义组件都有自己的生命周期，但并非所有生命周期函数都对所有组件有效。<br>自定义组件生命周期：每一个自定义组件@Component 都有自己的生命周期，但注意 Page 相关的周期只有 @Entry 的页面入口有<br>自定义组件生命周期时机：aboutToAppear()在 build 函数之前执行。用于组件显示前的准备工作。</p>
<h3 id="2-2-ArkUI-动画"><a href="#2-2-ArkUI-动画" class="headerlink" title="2.2 ArkUI 动画"></a>2.2 ArkUI 动画</h3><p>如何在 ArkTS 中实现动画效果？<br>ArkTS 可以使用 Animated 组件和动画属性来实现动画效果。例如，可以使用 Animated.Value 来创建一个动画值，然后通过设置组件的属性如 width、height、opacity 等与动画值进行绑定，再使用 Animated.timing、Animated.spring 等方法来创建动画效果。</p>
<h3 id="2-2-状态管理"><a href="#2-2-状态管理" class="headerlink" title="2.2 状态管理"></a>2.2 状态管理</h3><h4 id="都用过哪些装饰器？"><a href="#都用过哪些装饰器？" class="headerlink" title="都用过哪些装饰器？"></a>都用过哪些装饰器？</h4><p>@State @Watch @Link @Prop 等等，着重介绍如何使用，什么特性即可。</p>
<h4 id="常用的装饰器有哪些。"><a href="#常用的装饰器有哪些。" class="headerlink" title="常用的装饰器有哪些。"></a>常用的装饰器有哪些。</h4><p>装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component 和@State 都是装饰器，@Component 表示自定义组件，@Entry 表示该自定义组件为入口组件，@State 表示组件中的状态变量，状态变量变化会触发 UI 刷新。</p>
<ul>
<li>​</li>
</ul>
<h3 id="2-2-2-状态存储"><a href="#2-2-2-状态存储" class="headerlink" title="2.2.2 状态存储"></a>2.2.2 状态存储</h3><p>localStorage 和 appStorage 的区别</p>
<h4 id="localStorage-和-appStorage-的区别，和对应的装饰器"><a href="#localStorage-和-appStorage-的区别，和对应的装饰器" class="headerlink" title="localStorage 和 appStorage 的区别，和对应的装饰器"></a>localStorage 和 appStorage 的区别，和对应的装饰器</h4><ul>
<li>localStorage 是页面级数据存储，在页面中创建实例，组件中使用@LocalStorageLink 和@LocalStorageProp 装饰器修饰对应的状态变量，绑定对应的组件使用比状态属性更灵活</li>
<li>appStorage 是进程级数据存储，进程启动时自动创建了唯一实例，在各个页面组件中@StorageProp 和@StorageLink 装饰器修饰对应的状态变量。</li>
<li>localStorage 和 appStorage 数据存取都是在主线程进行的，且 api 只提供了同步接口，存取数据时要注意数据的大小。</li>
</ul>
<h5 id="如何在-ArkTS-中实现数据的本地存储？"><a href="#如何在-ArkTS-中实现数据的本地存储？" class="headerlink" title="如何在 ArkTS 中实现数据的本地存储？"></a>如何在 ArkTS 中实现数据的本地存储？</h5><p>ArkTS 可以使用@StorageLink 装饰器来实现数据的本地存储绑定。例如：@StorageLink(‘key’) value，其中 key 是存储的键名，value 是绑定的数据变量。通过这种方式，数据的变化会自动同步到本地存储，并且在应用启动时可以从本地存储中恢复数据。</p>
<h5 id="首选项异步存储在并发场景上的注意事项"><a href="#首选项异步存储在并发场景上的注意事项" class="headerlink" title="首选项异步存储在并发场景上的注意事项"></a>首选项异步存储在并发场景上的注意事项</h5><p>首选项 preference 提供了异步存储接口，首选项的数据存储维度分为内存和沙盒，为避免内存过大导致报警，要控制首选项数据存储的数据，可以使用 await 来控制并发存储的问题</p>
<h5 id="用户首选项是线程安全的吗"><a href="#用户首选项是线程安全的吗" class="headerlink" title="用户首选项是线程安全的吗"></a>用户首选项是线程安全的吗</h5><p>首选项是线程安全的，所以多线程访问可以保证数据一致性，但只支持同进程，不支持多进程。</p>
<h5 id="首选项底层逻辑？"><a href="#首选项底层逻辑？" class="headerlink" title="首选项底层逻辑？"></a>首选项底层逻辑？</h5><p>提供 key value 形式的 api。系统静态容器提供 pf 实例对象在内存中，对应获取沙箱中数据的文件。</p>
<p>注意轻量级，key 不为空且长度不超过 80 字节，value 若为 string 长度不超过 8192 字节。</p>
<h3 id="2-3-UI-布局"><a href="#2-3-UI-布局" class="headerlink" title="2.3 UI 布局"></a>2.3 UI 布局</h3><h4 id="2-3-1-常见布局方式"><a href="#2-3-1-常见布局方式" class="headerlink" title="2.3.1 常见布局方式"></a>2.3.1 常见布局方式</h4><h5 id="flex-导致二次布局的原因，以及调研的经历"><a href="#flex-导致二次布局的原因，以及调研的经历" class="headerlink" title="flex 导致二次布局的原因，以及调研的经历"></a>flex 导致二次布局的原因，以及调研的经历</h5><p>flex 中 flexgrow&#x3D;1 时，子组件宽度和大于 flex 的宽度时，页面渲染后，会调整子组件宽度使之宽度和等于 flex 的宽度，造成二次布局渲染</p>
<p>flex 中 flexshrink&#x3D;1 时，子组件宽度和小于 flex 的宽度时，页面渲染后，也会调整子组件宽度使之宽度和等于 flex 的宽度，造成二次布局渲染</p>
<h5 id="页面布局上的性能和内存上的注意事项"><a href="#页面布局上的性能和内存上的注意事项" class="headerlink" title="页面布局上的性能和内存上的注意事项"></a>页面布局上的性能和内存上的注意事项</h5><p>1、使用 row&#x2F;column+layoutweight 代替 flex 容器使用</p>
<p>2、scroll 嵌套 list&#x2F;grid 容器时，要设置容器的宽高，数组数据渲染尽量使用 lazyforeach 渲染 item</p>
<p>3、组件的显隐设置，要使用 if 语句来判断，避免使用 visibility</p>
<p>4、list&#x2F;grid 容器要根据具体场景来使用 cachecount，避免卡顿</p>
<h4 id="2-3-2-一多适配"><a href="#2-3-2-一多适配" class="headerlink" title="2.3.2 一多适配"></a>2.3.2 一多适配</h4><h5 id="开发一套代码，UI-同时适配手机，折叠屏和平板，怎么实现"><a href="#开发一套代码，UI-同时适配手机，折叠屏和平板，怎么实现" class="headerlink" title="开发一套代码，UI 同时适配手机，折叠屏和平板，怎么实现"></a>开发一套代码，UI 同时适配手机，折叠屏和平板，怎么实现</h5><p>媒体查询</p>
<h5 id="如何在-ArkTS-中实现响应式布局？"><a href="#如何在-ArkTS-中实现响应式布局？" class="headerlink" title="如何在 ArkTS 中实现响应式布局？"></a>如何在 ArkTS 中实现响应式布局？</h5><p>ArkTS 可以使用 Flex 布局和响应式属性来实现响应式布局。例如，可以使用 Flex 组件来创建弹性布局容器，并设置 justifyContent、alignItems 等属性来调整子元素的排列方式。同时，可以使用响应式属性如 width、height、margin 等，根据不同的设备尺寸和屏幕方向进行自适应调整。<br>解释一下 ArkTS 中的 Stack 组件的作用。<br>Stack 组件用于创建堆叠布局，可以将多个子组件按照指定的顺序堆叠在一起。可以设置 alignment 属性来调整子组件在堆叠方向上的对齐方式，还可以设置 clipToBounds 属性来控制子组件是否超出父容器的边界进行裁剪。</p>
<h5 id="flex-为什么有性能问题？flex-为什么影响性能？"><a href="#flex-为什么有性能问题？flex-为什么影响性能？" class="headerlink" title="flex 为什么有性能问题？flex 为什么影响性能？"></a>flex 为什么有性能问题？flex 为什么影响性能？</h5><p>flex 会二次重绘，因为 flexShrink</p>
<h5 id="用过哪些组件？"><a href="#用过哪些组件？" class="headerlink" title="用过哪些组件？"></a>用过哪些组件？</h5><p>row column stack list swiper RelativeContainer 等等</p>
<h2 id="3-通信与调度"><a href="#3-通信与调度" class="headerlink" title="3. 通信与调度"></a>3. 通信与调度</h2><h3 id="3-1-Ability-交互"><a href="#3-1-Ability-交互" class="headerlink" title="3.1 Ability 交互"></a>3.1 Ability 交互</h3><p>三方应用调用系统应用，对于 ability 的交互和传值有什么限制？除了数据大小方面</p>
<p>重点介绍自己对 ability 的理解，描述显式 want 和隐式 want 的区别，带入到对应面试项目中场景来</p>
<p>启动应用内的 UIAbility</p>
<p>启动应用内的 UIAbility 并获取返回结果</p>
<p>启动其他应用的 UIAbility</p>
<p>启动其他应用的 UIAbility 并获取返回结果</p>
<p>启动 UIAbility 的指定页面</p>
<p>显式 Want 启动：在 want 参数中需要设置该应用 bundleName 和 abilityName，当需要拉起某个明确的 UIAbility 时，通常使用显式 Want 启动方式。</p>
<p>隐式 Want 启动：不明确指出要启动哪一个 UIAbility，在调用 startAbility()方法时，其入参 want 中指定了一系列的 entities 字段（表示目标 UIAbility 额外的类别信息，如浏览器、视频播放器）和 actions 字段（表示要执行的通用操作，如查看、分享、应用详情等）等参数信息，然后由系统去分析 want，并帮助找到合适的 UIAbility 来启动。</p>
<h3 id="3-2-页面通信"><a href="#3-2-页面通信" class="headerlink" title="3.2 页面通信"></a>3.2 页面通信</h3><h3 id="3-3-组件通信"><a href="#3-3-组件通信" class="headerlink" title="3.3 组件通信"></a>3.3 组件通信</h3><h3 id="3-4-多线程通信"><a href="#3-4-多线程通信" class="headerlink" title="3.4 多线程通信"></a>3.4 多线程通信</h3><h3 id="3-4-路由跳转"><a href="#3-4-路由跳转" class="headerlink" title="3.4 路由跳转"></a>3.4 路由跳转</h3><h5 id="页面的跳转和数据传递"><a href="#页面的跳转和数据传递" class="headerlink" title="页面的跳转和数据传递"></a>页面的跳转和数据传递</h5><p>组件间怎么通信，传递数据</p>
<h5 id="组件通信方式有哪些？"><a href="#组件通信方式有哪些？" class="headerlink" title="组件通信方式有哪些？"></a>组件通信方式有哪些？</h5><p>H5 页面如何与 ArkTS 交互</p>
<h5 id="a-ability-拉-b-ability-类型会不会丢失？"><a href="#a-ability-拉-b-ability-类型会不会丢失？" class="headerlink" title="a ability 拉 b ability 类型会不会丢失？"></a>a ability 拉 b ability 类型会不会丢失？</h5><p>会丢</p>
<p>navigation 和 router 区别，优缺点</p>
<h5 id="页面栈"><a href="#页面栈" class="headerlink" title="页面栈"></a>页面栈</h5><p>页面栈数量：每调用一次 router.pushUrl()方法，默认情况下，页面栈数量会增加 1。鸿蒙系统对页面栈的数量有限制，通常是 32 个。<br>页面跳转销毁：router.replaceUrl()方法可以跳转到一个新页面，并销毁当前页面。 作者：维维喂喂微微 <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv33829990/">https://www.bilibili.com/read/cv33829990/</a> 出处：bilibili</p>
<h2 id="4-网络与多线程"><a href="#4-网络与多线程" class="headerlink" title="4. 网络与多线程"></a>4. 网络与多线程</h2><h3 id="4-1-网络"><a href="#4-1-网络" class="headerlink" title="4.1 网络"></a>4.1 网络</h3><h5 id="网络请求需要添加什么权限，在哪里添加"><a href="#网络请求需要添加什么权限，在哪里添加" class="headerlink" title="网络请求需要添加什么权限，在哪里添加"></a>网络请求需要添加什么权限，在哪里添加</h5><h5 id="谈谈-ArkTS-中数据请求的方法有哪些？"><a href="#谈谈-ArkTS-中数据请求的方法有哪些？" class="headerlink" title="谈谈 ArkTS 中数据请求的方法有哪些？"></a>谈谈 ArkTS 中数据请求的方法有哪些？</h5><p>可以使用原生的 JavaScript 中的 fetch 或 axios 等库来进行网络请求获取数据。在 ArkTS 中，可以在函数或组件的方法中调用这些库进行数据请求，并将获取的数据更新到组件的状态中，从而触发界面的更新。</p>
<h5 id="网络相关的三方库有哪些"><a href="#网络相关的三方库有哪些" class="headerlink" title="网络相关的三方库有哪些"></a>网络相关的三方库有哪些</h5><p>网络相关的三方库有 Axios、httpclient、okdownload 等，具体分类可以参考三四方库网络分类。</p>
<h5 id="如何监听网络变化"><a href="#如何监听网络变化" class="headerlink" title="如何监听网络变化"></a>如何监听网络变化</h5><p>在网络连接管理模块中通过 on(‘netCapabilitiesChange’)订阅网络能力变化事件，即可监听网络变化。<br>如何获取网络类型：Wi-Fi，3G，4G，5G 等<br>先通过 getNetCapabilities 去获取网络的类型，判断默认网络是 WIFI 还是蜂窝。</p>
<p>如果是 Wi-Fi，则直接确认网络类型是 Wi-Fi。如果是在蜂窝连接情况下，可以调用 radio.getSignalInformation 获取指定 SIM 卡槽对应的注册网络信号强度信息列表，返回 SignalInformation 对象的数组，其中，返回的 signalType 代表网络类型 NetworkType，signalType 的值对应网络类型如下：</p>
<p>GSM：2G<br>CDMA：电信 2G<br>WCDMA：3G<br>TDSCDMA：3G<br>LTE：4G<br>NR：5G</p>
<h5 id="项目中接口请求的数据，需要进行缓存吗？鸿蒙化处理过程"><a href="#项目中接口请求的数据，需要进行缓存吗？鸿蒙化处理过程" class="headerlink" title="项目中接口请求的数据，需要进行缓存吗？鸿蒙化处理过程"></a>项目中接口请求的数据，需要进行缓存吗？鸿蒙化处理过程</h5><p>根据自己项目中的业务逻辑描述，MapKit 需要将当前屏幕中展示的 6 个瓦片数据图片缓存到沙盒中，杀掉进程后，断开网络，打开 app 会展示缓存的数据瓦片。</p>
<h3 id="4-2-多线程"><a href="#4-2-多线程" class="headerlink" title="4.2 多线程"></a>4.2 多线程</h3><h5 id="如何判断是否为主线程"><a href="#如何判断是否为主线程" class="headerlink" title="如何判断是否为主线程"></a>如何判断是否为主线程</h5><h5 id="有哪些创建线程的方式"><a href="#有哪些创建线程的方式" class="headerlink" title="有哪些创建线程的方式"></a>有哪些创建线程的方式</h5><p>在 ArkTS 中使用 Worker 创建线程，Worker 线程在主线程中创建，与主线程相互独立，但不能直接操作 UI，最多可以创建 64 个 Worker 线程。<br>在 ArkTS 中使用任务池（TaskPool）创建线程任务。<br>通过 NAPI 机制，在 C 代码中使用标准的线程 API 创建线程。</p>
<h5 id="TaskPool-和-Worker-的异同点"><a href="#TaskPool-和-Worker-的异同点" class="headerlink" title="TaskPool 和 Worker 的异同点"></a>TaskPool 和 Worker 的异同点</h5><p>不同点：两者是不同颗粒度的并发 API，Worker 更像 Thread 或者 Service 维度，Task 就是单一任务维度。同时 TaskPool 简化开发者开发并发程序，支持优先级和取消，并且通过统一管理节省系统资源优化调度。<br>相同点：在 JS 相关的线程间交互上，二者本质都是内存隔离模型，参数与范围值的限制是一致的，也有开销。</p>
<h4 id="Worker-和-TaskPool-的线程数量是否有限制"><a href="#Worker-和-TaskPool-的线程数量是否有限制" class="headerlink" title="Worker 和 TaskPool 的线程数量是否有限制"></a>Worker 和 TaskPool 的线程数量是否有限制</h4><p>TaskPool 内部会动态调整线程个数，不支持设置数量，只需要往线程池中抛任务，确保高优先级任务的及时执行。</p>
<p>Worker 的线程个数最多 64 个，如果 Worker 超过规定个数，会创建失败。</p>
<p>在使用时，TaskPool 与 Worker 两者独立，不相互影响，因此 Worker 在达到上限数量时，不会影响 TaskPool。Worker 是固定数量，当前是 64 个。TaskPool 线程池的数量会根据硬件条件、任务负载等情况动态调整。</p>
<h5 id="在多线程并发场景中，如何实现安全访问同一块共享内存"><a href="#在多线程并发场景中，如何实现安全访问同一块共享内存" class="headerlink" title="在多线程并发场景中，如何实现安全访问同一块共享内存"></a>在多线程并发场景中，如何实现安全访问同一块共享内存</h5><p>可以使用共享对象 SharedArrayBuffer 实现。SharedArrayBuffer 对象存储的数据在同时被修改时，需要通过 Atomics 原子操作保证其同步性，即下个操作开始之前务必需要等到上个操作已经结束。<br>如何实现多线程数据共享<br>由于 ArkTS 是单线程模型，内存隔离，因此大部分普通对象跨线程均采用序列化方式，通过 ArrayBuffer 的转移传输和 SharedArrayBuffer 进行共享。</p>
<h5 id="多线程怎么保证并发一致性？"><a href="#多线程怎么保证并发一致性？" class="headerlink" title="多线程怎么保证并发一致性？"></a>多线程怎么保证并发一致性？</h5><p>队列，同步锁</p>
<h5 id="多进程-sp-怎么保证一致性？"><a href="#多进程-sp-怎么保证一致性？" class="headerlink" title="多进程 sp 怎么保证一致性？"></a>多进程 sp 怎么保证一致性？</h5><p>分为两种情况，读，不需要处理。写，需要加锁。</p>
<h5 id="主线程上的数据对象序列化后传到子线程，子线程改变了对象的属性值，主线程跟着一起改变吗"><a href="#主线程上的数据对象序列化后传到子线程，子线程改变了对象的属性值，主线程跟着一起改变吗" class="headerlink" title="主线程上的数据对象序列化后传到子线程，子线程改变了对象的属性值，主线程跟着一起改变吗"></a>主线程上的数据对象序列化后传到子线程，子线程改变了对象的属性值，主线程跟着一起改变吗</h5><p>不会变</p>
<h5 id="子线程和主线程的消息传递"><a href="#子线程和主线程的消息传递" class="headerlink" title="子线程和主线程的消息传递"></a>子线程和主线程的消息传递</h5><p>目前鸿蒙线程间通信使用 emitter</p>
<h5 id="promise-和-callback-的区别？"><a href="#promise-和-callback-的区别？" class="headerlink" title="promise 和 callback 的区别？"></a>promise 和 callback 的区别？</h5><p>promise 没有解决回调的问题，因为 then 本身也是回调，但他规范一套异步的规范，符合 promise a+规范的都是 promise，这个对于写各种库的人来说规范了他们的接口格式，开发者在使用各种接口的时候不用考虑这个传啥回调那个传啥回调</p>
<h5 id="promise-then-是在哪个线程里？"><a href="#promise-then-是在哪个线程里？" class="headerlink" title="promise.then 是在哪个线程里？"></a>promise.then 是在哪个线程里？</h5><p>then 里面的处理是在主线程。</p>
<h5 id="then-调用和-await-调用的区别"><a href="#then-调用和-await-调用的区别" class="headerlink" title=".then 调用和 await 调用的区别"></a>.then 调用和 await 调用的区别</h5><pre><code>当使用Promise进行异步操作时，可以使用.then和await两种方式来调用异步接口；.then调用不阻塞当前线程，异步回调结束后会直接走到then中，await会等待当前异步方法执行结束才会继续往下执行。
</code></pre>
<h5 id="taskpool-开启子线程和-promise-的区别"><a href="#taskpool-开启子线程和-promise-的区别" class="headerlink" title="taskpool 开启子线程和 promise 的区别"></a>taskpool 开启子线程和 promise 的区别</h5><p>taskpool 开辟子线程能够充分利用现代手机设备多核配置，提高程序的并发性和运行效率；Promise 是在当前线程进行异步调用，可以避免阻塞主线程，保证程序的响应速度，提高用户体验；</p>
<pre><code>具体使用场景：当需要执行I/O操作时，使用异步操作比使用线程+同步I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。当需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行时，建议使用子线程操作。
</code></pre>
<h5 id="两个按钮分别调用一个异步-async-代码，里面有多个-await，他们会不会交叉进行？"><a href="#两个按钮分别调用一个异步-async-代码，里面有多个-await，他们会不会交叉进行？" class="headerlink" title="两个按钮分别调用一个异步 async 代码，里面有多个 await，他们会不会交叉进行？"></a>两个按钮分别调用一个异步 async 代码，里面有多个 await，他们会不会交叉进行？</h5><p>会交叉。async 和 await 是 promise 的语法糖，相当于将当前执行栈的任务全部包含到 then 里面</p>
<h5 id="worker-和-taskpool-的区别？"><a href="#worker-和-taskpool-的区别？" class="headerlink" title="worker 和 taskpool 的区别？"></a>worker 和 taskpool 的区别？</h5><p>前者是子线程并发处理，后者是异步批量处理。worker 最多只有 8 个。taskpool 处理超过三分钟就会失效。</p>
<h5 id="鸿蒙系统-http-在接口请求时，系统本身应该是开启子线程来请求，那么为什么在项目中还要使用-taskpool-开辟子线程呢"><a href="#鸿蒙系统-http-在接口请求时，系统本身应该是开启子线程来请求，那么为什么在项目中还要使用-taskpool-开辟子线程呢" class="headerlink" title="鸿蒙系统 http 在接口请求时，系统本身应该是开启子线程来请求，那么为什么在项目中还要使用 taskpool 开辟子线程呢"></a>鸿蒙系统 http 在接口请求时，系统本身应该是开启子线程来请求，那么为什么在项目中还要使用 taskpool 开辟子线程呢</h5><pre><code>鸿蒙底层的http请求实现是在子线程中进行的，但针对于请求参数的编码与返回值的解析，这部分需要花费时间来处理的业务逻辑，还是建议使用taskpool开辟子线程来处理
</code></pre>
<h2 id="5-ArkWeb：与-H5-交互"><a href="#5-ArkWeb：与-H5-交互" class="headerlink" title="5.ArkWeb：与 H5 交互"></a>5.ArkWeb：与 H5 交互</h2><h5 id="webview-交互，传递数据"><a href="#webview-交互，传递数据" class="headerlink" title="webview 交互，传递数据"></a>webview 交互，传递数据</h5><h4 id="h5-跟-arkts-怎么交互？"><a href="#h5-跟-arkts-怎么交互？" class="headerlink" title="h5 跟 arkts 怎么交互？"></a>h5 跟 arkts 怎么交互？</h4><p>runJavaScript（） arkts-》H5</p>
<p>javaScriptProxy() 和 registerjavaScriptProxy() H5-》arkts</p>
<p>拦截 url 过滤</p>
<p>createWebMessagePorts postMessage onMessageEvent 数据通道</p>
<h5 id="H5-页面如何与-ArkTS-交互"><a href="#H5-页面如何与-ArkTS-交互" class="headerlink" title="H5 页面如何与 ArkTS 交互"></a>H5 页面如何与 ArkTS 交互</h5><p>通过对 javaScriptProxy 和 runJavaScript 封装，实现 JSBridge 通信方案。使用 Web 组件 javaScriptProxy 将原生侧接口注入到 H5 的 window 对象上，通过 runJavaScript 接口执行 JS 脚本到 H5 中，并在回调中获取脚本执行结果</p>
<h2 id="7-鸿蒙-Native-NAPI"><a href="#7-鸿蒙-Native-NAPI" class="headerlink" title="7.鸿蒙 Native: NAPI"></a>7.鸿蒙 Native: NAPI</h2><h4 id="从介绍中延伸出-har-和下沉到系统的-so-的优缺点"><a href="#从介绍中延伸出-har-和下沉到系统的-so-的优缺点" class="headerlink" title="从介绍中延伸出 har 和下沉到系统的 so 的优缺点"></a>从介绍中延伸出 har 和下沉到系统的 so 的优缺点</h4><p>har 分为静态分享库和动态分享库，静态分享库生成 har 包集成到应用中，应用运行时直接加载到进程中，动态分享库生成 hsp 和 har 包，har 集成到应用中，hsp 需要安装到手机设备中，应用运行时，har 直接加载到进程中，但 hsp 需要业务调用才会加载；</p>
<p>so 是 c++和 arkts 的混编，arkts 开发完成后，编译生成对应的 js 文件，使用华为工具将 js 文件和 NAPI 混编为 so；</p>
<p>目前 api10 和 api11 不支持 har 包下沉到系统称为预置 SDK，仅支持 so。</p>
<h2 id="8-工具链"><a href="#8-工具链" class="headerlink" title="8. 工具链"></a>8. 工具链</h2><p>如何使用 ohpm 引入三四方库</p>
<h2 id="9-性能优化"><a href="#9-性能优化" class="headerlink" title="9.性能优化"></a>9.性能优化</h2><h4 id="如何优化-ArkTS-组件的性能"><a href="#如何优化-ArkTS-组件的性能" class="headerlink" title="如何优化 ArkTS 组件的性能"></a>如何优化 ArkTS 组件的性能</h4><ul>
<li>避免不必要的重新渲染：使用@Watch 装饰器来监听数据变化，只有当相关数据发生变化时才进行组件的重新渲染。</li>
<li>合理使用列表渲染：对于大量数据的列表，可以使用 ForEach 组件来提高性能。</li>
<li>减少不必要的计算：避免在组件的 build 方法中进行复杂的计算，尽量将计算提前到数据准备阶段。</li>
</ul>
<h5 id="在-ArkTS-开发中，有哪些方法可以提高应用的性能？"><a href="#在-ArkTS-开发中，有哪些方法可以提高应用的性能？" class="headerlink" title="在 ArkTS 开发中，有哪些方法可以提高应用的性能？"></a>在 ArkTS 开发中，有哪些方法可以提高应用的性能？</h5><p>答案：可以通过优化数据结构、避免不必要的计算、合理使用缓存、减少页面的重绘和回流等方式提高应用性能。在界面开发中，尽量使用简单的布局和组件，避免过度嵌套。</p>
<h5 id="解释一下-ArkTS-中的-LazyForEach-组件的作用"><a href="#解释一下-ArkTS-中的-LazyForEach-组件的作用" class="headerlink" title="解释一下 ArkTS 中的 LazyForEach 组件的作用"></a>解释一下 ArkTS 中的 LazyForEach 组件的作用</h5><p>LazyForEach 组件用于在列表渲染时实现懒加载。当列表中的项很多时，LazyForEach 可以只渲染可见区域的项，当用户滚动列表时，再逐步加载其他项，从而提高性能和减少内存占用。</p>
<h5 id="list-使用有什么坑？渲染逻辑？"><a href="#list-使用有什么坑？渲染逻辑？" class="headerlink" title="list 使用有什么坑？渲染逻辑？"></a>list 使用有什么坑？渲染逻辑？</h5><p>list 默认会把 listitem 全部都渲染出来，数据量大会对内存造成压力。LazyForEach，只加载可见区域。</p>
<h5 id="页面性能内存优化？"><a href="#页面性能内存优化？" class="headerlink" title="页面性能内存优化？"></a>页面性能内存优化？</h5><p>性能和内存是两个指标，有时候追求性能，就需要做缓存处理，吃内存。</p>
<p>页面内存优化，主要在减少缓存的处理。</p>
<p>性能优化，主要在少嵌套，减少动态渲染的频率。</p>
<h5 id="装饰器-组件间通信-性能优化-数据持久化存取"><a href="#装饰器-组件间通信-性能优化-数据持久化存取" class="headerlink" title="装饰器,组件间通信,性能优化,数据持久化存取"></a>装饰器,组件间通信,性能优化,数据持久化存取</h5><h5 id="lazyforeach-使用相关的"><a href="#lazyforeach-使用相关的" class="headerlink" title="lazyforeach 使用相关的"></a>lazyforeach 使用相关的</h5><h2 id="10-实际项目中遇到的疑难问题与解决方法"><a href="#10-实际项目中遇到的疑难问题与解决方法" class="headerlink" title="10. 实际项目中遇到的疑难问题与解决方法"></a>10. 实际项目中遇到的疑难问题与解决方法</h2><h5 id="遇到过什么问题-分享一个你在使用-ArkTS-开发过程中遇到并解决的实际问题"><a href="#遇到过什么问题-分享一个你在使用-ArkTS-开发过程中遇到并解决的实际问题" class="headerlink" title="遇到过什么问题 分享一个你在使用 ArkTS 开发过程中遇到并解决的实际问题"></a>遇到过什么问题 分享一个你在使用 ArkTS 开发过程中遇到并解决的实际问题</h5></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-04T14:41:12.000Z" title="2022/12/4 22:41:12">2022-12-04</time>发表</span><span class="level-item"><time dateTime="2025-06-28T13:18:17.511Z" title="2025/6/28 21:18:17">2025-06-28</time>更新</span><span class="level-item">几秒读完 (大约108个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/04/%E5%AE%9E%E7%94%A8%E5%B0%8F%E8%BD%AF%E4%BB%B6/">实用小软件</a></p><div class="content"><p>软件：</p>
<ul>
<li>Snipate：截图<ul>
<li>f1截图，f1+fn</li>
<li>f3定在屏幕上，f3+fn</li>
<li>取色：shift切换</li>
</ul>
</li>
<li>ZoomIt：画笔<ul>
<li>ctrl+1放大</li>
<li>Ctrl+2画图</li>
<li>画图时按住Ctrl是矩形</li>
<li>画图时按住tab是椭圆</li>
<li>画图时按字母切换画笔颜色。r红色、b蓝色、g绿色、p粉色、o橙色</li>
</ul>
</li>
<li>XMind：思维导图<ul>
<li>enter同级</li>
<li>tab下级</li>
</ul>
</li>
<li>Typora：Markdown<ul>
<li>主题可下载</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-10T13:07:09.000Z" title="2021/3/10 21:07:09">2021-03-10</time>发表</span><span class="level-item"><time dateTime="2025-06-28T13:20:46.704Z" title="2025/6/28 21:20:46">2025-06-28</time>更新</span><span class="level-item">1 分钟读完 (大约144个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/10/vscode%E5%AE%9E%E7%94%A8%E5%B0%8F%E8%AE%B0/">vscode实用小记</a></p><div class="content"><p>VSCode插件：</p>
<ul>
<li>Error Lens：报错</li>
<li>One Dark Pro：颜色主题</li>
<li>Live Server ：实时预览，左右分屏</li>
<li>Auto Rename Tag：修改名字</li>
<li>Open In Browser：浏览器中打开</li>
<li>VSCode Icons：设置文件图标</li>
<li>Easy Less：less编译</li>
<li>CSSREM</li>
</ul>
<p>vscode快捷键：</p>
<p>shift+alt+下箭头(上箭头)：复制一行</p>
<p>ctrl+d：选中多个相同的单词</p>
<p>ctrl+alt+下箭头(上箭头)：添加多个光标</p>
<p>ctrl+h：全局替换某个单词</p>
<p>ctrl+g：跳转到指定的某一行</p>
<p>shift+alt+鼠标选中：选中某一区块</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-22T14:23:11.000Z" title="2021/2/22 22:23:11">2021-02-22</time>发表</span><span class="level-item"><time dateTime="2025-06-29T19:11:34.281Z" title="2025/6/30 03:11:34">2025-06-30</time>更新</span><span class="level-item">32 分钟读完 (大约4736个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p><div class="content"><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h1><h2 id="1-设计模式概述"><a href="#1-设计模式概述" class="headerlink" title="1. 设计模式概述"></a><strong>1. 设计模式概述</strong></h2><p><strong>23种设计模式</strong>可以分为<strong>三大类</strong>：</p>
<ul>
<li><code>创建型模式</code>5种</li>
<li><code>结构型模式</code>7种</li>
<li><code>行为型模式</code>11种</li>
</ul>
<p><strong>软件设计原则</strong></p>
<ul>
<li>开闭原则：对扩展开放，对修改关系。接口和抽象类，增加派生类即可。 </li>
<li>里氏代换原则：子类继承父类的方法，尽量不要改变父类方法的功能。</li>
<li>依赖倒转原则：高层模块不依赖于低层模块，两者应该依赖其抽象，抽象不应该依赖细节，细节应该依抽象。具体实现可以参考泛型的思想。</li>
<li>接口隔离原则：最小化依赖。一个类对另一个类的依赖应该建立在最小的接口上。</li>
<li>迪米特法则：最小知识原则，不跟”陌生人”说话，降低耦合度。与当前对象存在关联、聚合、组合关系，可直接访问的。</li>
<li>合成复用原则：尽量先试用组合或者聚合等关联关系实现，其次才考虑继承关系来实现。继承为白盒复用，合成复用为黑盒复用。</li>
</ul>
<p><strong>UML图</strong>-统一建模语言</p>
<p>定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等9种图</p>
<p>类图：field&#x2F;method</p>
<p><code>+</code>：表示public</p>
<p><code>-</code>：表示private</p>
<p><code>#</code>：表示protected</p>
<p>属性完整表示方式：可见性 名称 ： 类型 [ &#x3D; 缺省值]</p>
<p>方法完整表示方式：可见性 名称：（参数列表）[：返回类型]</p>
<p>备注：中括号里面的内容为可选</p>
<p><strong>类与类之间的关系</strong>：</p>
<p>关联关系一般分为：<code>一般关联关系</code>、<code>聚合关系</code>、<code>组合关系</code></p>
<p><code>一般关联关系</code>又可以分为：单向关联、双向关联、自关联</p>
<ul>
<li>关联关系<ul>
<li>单向关联：带箭头的实线</li>
<li>双向关联：不带箭头的实线</li>
<li>自关联：带有箭头且指向自身的实线</li>
</ul>
</li>
</ul>
<p><code>聚合关联关系</code>：是强关联关系，是整体和部分之间的关系。聚合关系也是通过成员对象来实现的，成员对象是整体对象的一部分，成员对象可以脱离整体对象而独立存在。<code>空心菱形的实线表示，菱形指向整体</code>。例如：学校和老师的关系。</p>
<p><code>组合关系</code>：也是整体和部分的关系，但它是一种更强烈的聚合关系。整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也不存在，部分对象不能脱离整体而存在。<code>实心菱形的实线表示，菱形指向整体</code>。例如：头和嘴的关系。</p>
<p><code>依赖关系</code>：它是耦合度最弱的关联关系，是临时性的关系。<code>带箭头的虚线表示，箭头从使用类指向被依赖的类</code>。例如：人开车，其中人和汽车的关系。</p>
<p><code>继承关系</code>：继承关系(泛化关系)是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类的关系，是一种继承关系。<code>空心三角箭头的实线表示，箭头从子类指向父类</code>。例如：父亲和儿子。</p>
<p><code>实现关系</code>：实现类实现了接口中所声明的所有抽象方法。<code>带空心三角箭头的虚线表示，箭头从实现类指向接口</code>。例如：交通工具与汽车的关系。</p>
<h2 id="2-创建型模式（5种）"><a href="#2-创建型模式（5种）" class="headerlink" title="2. 创建型模式（5种）"></a><strong>2. 创建型模式（5种）</strong></h2><p>实现创建和使用分离。</p>
<h3 id="2-1-单例模式"><a href="#2-1-单例模式" class="headerlink" title="2.1 单例模式"></a><strong>2.1 单例模式</strong></h3><p>singleton pattern</p>
<p>分为两种：</p>
<ul>
<li><p><code>饿汉式</code>：类加载就会导致该单例对象被创建</p>
</li>
<li><p><code>懒汉式</code>：类加载不会导致该单例对象被创建，而是首次使用该对象时会被创建</p>
</li>
</ul>
<p><code>//饿汉式-静态变量创建的对象-方式1</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//私有构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>饿汉式-在静态代码块中创建该类对象-方式2</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//私有构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>饿汉式-枚举方式-方式3</code></p>
<p>枚举类实现单例模式是极力推荐的单例实现方式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>懒汉式-线程不安全-方式1</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//私有构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>懒汉式-线程安全-方式2</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//私有构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>懒汉式-双重检查锁-方式3</code></p>
<p>方式2中加锁操作虽然线程安全，但是也有性能问题，因为绝大多数的操作是读操作，而读操作本身就是线程安全的，没必要去加锁。所以，没有必要让每个线程必须持有锁才能调用getInstance。需要调整加锁的时机，由此产生下面双重检查锁的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//私有构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">  <span class="comment">//volatile解决多线程中空指针问题(JVM在实例化对象的时候会进行优化和指令重排序操作，使用volatile保证可见性和有序性)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一次判断，如果instance的值不为null，不需要抢占锁，直接返回对象</span></span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">        <span class="comment">//第二次判断</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><code>懒汉式-静态内部类-方式4</code></p>
<p>静态内部类单例模式中实例由内部类创建，由于JVM中加载外部类的过程中，是不会有加载静态内部类的，只有内部类的属性&#x2F;方法被调用才会被加载，并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且能严格保证实例化顺序。</p>
<p>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式，在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//私有构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在的问题</p>
<p>破坏单例模式：使用上面的单例类可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。 </p>
<p>通过<code>readResolve()</code>可以解决序列化破坏单例模式的问题。 </p>
<p>通过在私有构造方法中添加代码可以解决破坏单例模式的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//私有构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反射破坏单例模式需要添加的代码</span></span><br><span class="line">    <span class="keyword">if</span>(instance !=<span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">  <span class="comment">//volatile解决多线程中空指针问题(JVM在实例化对象的时候会进行优化和指令重排序操作，使用volatile保证可见性和有序性)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一次判断，如果instance的值不为null，不需要抢占锁，直接返回对象</span></span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">        <span class="comment">//第二次判断</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>JDK的源码解析-Runtime类</p>
<p>Runtime类使用的就是单例设计模式。</p>
<h3 id="2-2-工厂方法模式"><a href="#2-2-工厂方法模式" class="headerlink" title="2.2 工厂方法模式"></a><strong>2.2 工厂方法模式</strong></h3><p><strong>实际应用场景：</strong></p>
<ul>
<li>证券分类：股票（沪市（主板、科创板）、深市（主板、创业板）、京市（新三板、创新层））、债券（国债、公司债）、基金（公募基金、ETF基金）等都是证券，这里的证券就是抽象产品，而股票等就是具体产品。证券代码、证券价格等就是抽象工厂中应该定义的，具体工厂就是</li>
</ul>
<p>Coffee类  addSugar addMilk  抽象类</p>
<p>美式咖啡、拿铁咖啡  实现类</p>
<p>工厂模式最大的优点就是解耦。</p>
<p>简单工厂模式，不是一种设计模式，反而像是一种编程习惯。</p>
<p>静态工厂模式，不是一种设计模式，也只是一种编程习惯。</p>
<p>针对上面的问题，我们可以使用<code>工厂方法模式</code>，完全遵循开闭原则。</p>
<p>定义一个用于创建对象的接口，让子类决定石化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类中。</p>
<p>工厂方法模式：</p>
<ul>
<li>抽象工厂(Abstract Factory)：提供了创建产品的<code>接口</code>，调用者通过它访问具体的工厂方法来创建产品。-接口</li>
<li>具体工厂(Concrete Factory)：主要是<code>实现抽象工厂中的抽象方法</code>，完成具体产品创建。</li>
<li>抽象产品(Product)：定义了产品规范 ，描述了产品的主要特征和功能。</li>
<li>具体产品(Concrete Product)：实现了抽象产品角色定义的接口，由具体工厂来创建，同具体工厂<code>一一对应</code>。</li>
</ul>
<p><img src="/image/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="工厂方法模式"></p>
<p>优缺点：</p>
<ul>
<li>优点：<ul>
<li>用户只需知道具体工厂的名称就可以得到所需要的产品，无需知道产品的具体创建过程。</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无需对原工厂进行修改，满足开闭原则。</li>
</ul>
</li>
<li>缺点：<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li>
</ul>
</li>
</ul>
<h3 id="2-3-抽象工厂模式"><a href="#2-3-抽象工厂模式" class="headerlink" title="2.3 抽象工厂模式"></a><strong>2.3 抽象工厂模式</strong></h3><p>工厂方法模式只考虑生产<code>同级别产品</code>，但是在现实生活中许多工厂是综合性的工厂，能生产<code>多种类产品</code>。</p>
<p>抽象工厂模式是一种为访问类提供一个创建一组<code>相关</code>或<code>相互依赖</code>对象的<code>接口</code>，且访问类无需指定所要产品的具体类就能得到同族的不同级别的产品的模式接口。</p>
<p>抽象工厂模式是工厂方法模式的升级版，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<ul>
<li>抽象工厂(Abstract Factory)：提供了创建产品的<code>接口</code>，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂(Concrete Factory)：主要是<code>实现抽象工厂中的多个抽象方法</code>，完成具体产品创建。</li>
<li>抽象产品(Product)：定义了产品规范 ，描述了产品的主要特征和功能。抽象工厂模式有多个抽象产品。</li>
<li>具体产品(Concrete Product)：实现了抽象产品角色定义的接口，由具体工厂来创建，同具体工厂之间是<code>多对一的关系</code>。</li>
</ul>
<p><img src="/image/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="抽象工厂模式"></p>
<p>优缺点：</p>
<ul>
<li>优点：当一个产品族中多个对象被设计成在一起工作时，它能保证客户端始终只使用一个产品中的对象。</li>
<li>缺点：当产品族中增加一个新的产品时，所有的工作类都要进行修改。</li>
</ul>
<p>应用场景：换肤，一整套一起换。颜色、字体、图标等。</p>
<p>模式扩展</p>
<p>简单工厂+配置文件接触耦合</p>
<p>加载配置文件，获取配置文件中配置的全类名，并创建该类的对象进行存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1.定义容器对象存储咖啡对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Coffee&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Coffee&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.加载配置文件，只需要加载一次</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> CoffeeFactory.class.getClassLoader().getResourceAsStream(name:<span class="string">&quot;bean.propert.....&quot;</span>)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        p.load(is);</span><br><span class="line">        Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Object key:keys)&#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> p.getProperty((String) key);</span><br><span class="line">          <span class="comment">//通过反射技术创建对象</span></span><br><span class="line">          <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">          <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> (Coffee) clazz.newInstance();</span><br><span class="line">          <span class="comment">//将名称和对象存储到容器中</span></span><br><span class="line">          map.put((String)key,coffee);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//根据名称获取对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">creatCoffee</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK源码解析-Collection.iterator方法</p>
<ul>
<li>抽象工厂(Abstract Factory)：提供了创建产品的<code>接口</code>。Collection</li>
<li>具体工厂(Concrete Factory)：主要是<code>实现抽象工厂中的多个抽象方法</code>，完成具体产品创建。ArrayList</li>
<li>抽象产品(Product)：定义了产品规范 ，描述了产品的主要特征和功能。iterator </li>
<li>具体产品(Concrete Product)：实现了抽象产品角色定义的接口，由具体工厂来创建。ArrayList$Iter</li>
</ul>
<p>Collection接口是抽象工厂类，ArrayList是具体的工厂类，Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。</p>
<p>抽象工厂类、抽象产品类 用的都是接口。</p>
<p><img src="/image/ArrayList.png" alt="ArrayList"></p>
<h3 id="2-4-原型模式"><a href="#2-4-原型模式" class="headerlink" title="2.4 原型模式"></a><strong>2.4 原型模式</strong></h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和该原型对象相同的新对象。</p>
<p>抽象原型类：规定了具体原型对象必须实现的clone()方法。</p>
<p>具体原型类：实现抽象原型类的clone()方法，它是可被复制的对象。</p>
<p>访问类：使用具体原型类中的clone()方法来复制新的对象。</p>
<h3 id="2-5-建造者模式"><a href="#2-5-建造者模式" class="headerlink" title="2.5 建造者模式"></a><strong>2.5 建造者模式</strong></h3><h2 id="3-结构型模式（7种）"><a href="#3-结构型模式（7种）" class="headerlink" title="3. 结构型模式（7种）"></a><strong>3. 结构型模式（7种）</strong></h2><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为<code>类结构性模式</code>和<code>对象结构型模式</code>。</p>
<ul>
<li><code>类结构型模式</code>采用<code>继承</code>机制来组织接口和类。例如：</li>
<li><code>对象结构型模式</code>采用<code>组合</code>或<code>聚合</code>来组合对象。例如：代理模式、</li>
</ul>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足<code>合成复用原则</code>，所以对象结构型模式比类结构型模式有更大的灵活性。</p>
<h3 id="3-1-代理模式-Proxy"><a href="#3-1-代理模式-Proxy" class="headerlink" title="3.1 代理模式 Proxy"></a><strong>3.1 代理模式 Proxy</strong></h3><p>由于某些原因需要给某<code>对象</code>提供一个<code>代理</code>以控制该<code>对象</code>的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<ul>
<li>静态代理：编译期生成</li>
<li>动态代理：运行时生成，JDK代理(接口代理)、CGLIB代理</li>
</ul>
<p>代理模式分为三种角色：</p>
<ul>
<li>抽象主题类(Subject)：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题类(Real Subject)：实现了抽象主题中的具体业务，是代理对象锁代表的真实对象，是最终要引用的对象。</li>
<li>代理类(Proxy)：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<h3 id="3-2-适配器模式-Adapter"><a href="#3-2-适配器模式-Adapter" class="headerlink" title="3.2 适配器模式 Adapter"></a><strong>3.2 适配器模式 Adapter</strong></h3><p><strong>实际应用场景</strong>：</p>
<ul>
<li><code>实际项目中的引用，行情服务从一个服务商切换到另一个服务商，例如：行情数据、个股详情数据</code></li>
</ul>
<p><strong>定义</strong>：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的哪些类能一起工作。</p>
<p><strong>适配器模式</strong>分为<code>类适配器模式</code>和<code>对象适配器模式</code>：</p>
<ul>
<li><code>类适配器模式</code>：耦合度比比对象适配器高，较少使用。</li>
<li><code>对象适配器模式</code>：使用较多。</li>
</ul>
<p><strong>适配器模式</strong>包含一下<strong>主要角色</strong>：</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<p>类适配器：</p>
<p>违背了合成复用原则，类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p>
<p>对象适配器：对象适配器模式可采用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。  </p>
<p>接口适配器：当不希望实现一个接口中的所有的方法时，可以创建一个抽象类Adapter，实现所有方法，而此时我们只需继承该抽象类即可。</p>
<h3 id="3-3桥接模式"><a href="#3-3桥接模式" class="headerlink" title="3.3桥接模式"></a>3.3桥接模式</h3><h3 id="3-4-装饰者模式"><a href="#3-4-装饰者模式" class="headerlink" title="3.4 装饰者模式"></a>3.4 装饰者模式</h3><h3 id="3-5-外观模式"><a href="#3-5-外观模式" class="headerlink" title="3.5 外观模式"></a>3.5 外观模式</h3><h3 id="3-6享元模式"><a href="#3-6享元模式" class="headerlink" title="3.6享元模式"></a>3.6享元模式</h3><h3 id="3-7-组合模式"><a href="#3-7-组合模式" class="headerlink" title="3.7 组合模式"></a>3.7 组合模式</h3><h2 id="4-行为型模式（11种）"><a href="#4-行为型模式（11种）" class="headerlink" title="4. 行为型模式（11种）"></a>4. 行为型模式（11种）</h2><h3 id="4-1-模版方法模式"><a href="#4-1-模版方法模式" class="headerlink" title="4.1 模版方法模式"></a>4.1 模版方法模式</h3><h3 id="4-2-策略模式"><a href="#4-2-策略模式" class="headerlink" title="4.2 策略模式"></a>4.2 策略模式</h3><h3 id="4-3-命令模式"><a href="#4-3-命令模式" class="headerlink" title="4.3 命令模式"></a>4.3 命令模式</h3><h3 id="4-4-责任链模式"><a href="#4-4-责任链模式" class="headerlink" title="4.4 责任链模式"></a>4.4 责任链模式</h3><h3 id="4-5-状态模式"><a href="#4-5-状态模式" class="headerlink" title="4.5 状态模式"></a>4.5 状态模式</h3><h3 id="4-6-观察者模式"><a href="#4-6-观察者模式" class="headerlink" title="4.6 观察者模式"></a>4.6 观察者模式</h3><h3 id="4-7中介者模式"><a href="#4-7中介者模式" class="headerlink" title="4.7中介者模式"></a>4.7中介者模式</h3><h3 id="4-8-迭代器模式"><a href="#4-8-迭代器模式" class="headerlink" title="4.8 迭代器模式"></a>4.8 迭代器模式</h3><h3 id="4-9-访问者模式"><a href="#4-9-访问者模式" class="headerlink" title="4.9 访问者模式"></a>4.9 访问者模式</h3><h3 id="4-10-备忘录模式"><a href="#4-10-备忘录模式" class="headerlink" title="4.10 备忘录模式"></a>4.10 备忘录模式</h3><h3 id="4-11-解释器模式"><a href="#4-11-解释器模式" class="headerlink" title="4.11 解释器模式"></a>4.11 解释器模式</h3><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="TaoFei"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TaoFei</p><p class="is-size-6 is-block">Senior Cross-Platform Frontend Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hefei, Anhui, P.R.China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/mannerable" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/mannerable"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-12T15:20:10.000Z">2025-05-12</time></p><p class="title"><a href="/2025/05/12/%E9%B8%BF%E8%92%99%E9%9D%A2%E8%AF%95/">鸿蒙面试笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-04T14:41:12.000Z">2022-12-04</time></p><p class="title"><a href="/2022/12/04/%E5%AE%9E%E7%94%A8%E5%B0%8F%E8%BD%AF%E4%BB%B6/">实用小软件</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-10T13:07:09.000Z">2021-03-10</time></p><p class="title"><a href="/2021/03/10/vscode%E5%AE%9E%E7%94%A8%E5%B0%8F%E8%AE%B0/">vscode实用小记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-22T14:23:11.000Z">2021-02-22</time></p><p class="title"><a href="/2021/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/bitg.png" alt="The Bit Garden" height="28"></a><p class="is-size-7"><span>&copy; 2025 TaoFei</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2016 - 2025, TaoFei. All rights reserved.</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>